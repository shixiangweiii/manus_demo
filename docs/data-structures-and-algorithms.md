# æ•°æ®ç»“æ„ä¸ç®—æ³•è¯¦è§£

> æœ¬æ–‡æ¡£ç³»ç»Ÿæ¢³ç† DAG é©±åŠ¨çš„å¤šæ™ºèƒ½ä½“ Demoï¼ˆv4ï¼šå«æ··åˆè§„åˆ’è·¯ç”±ï¼‰ä¸­ç”¨åˆ°çš„å…¨éƒ¨æ•°æ®ç»“æ„ä¸ç®—æ³•ï¼Œ
> æŒ‰ **åŸºç¡€ â†’ æ ¸å¿ƒ â†’ ç»„åˆåº”ç”¨** çš„é¡ºåºæ’åˆ—ï¼Œæ¯ä¸ªçŸ¥è¯†ç‚¹éƒ½é…æœ‰å¤§ç™½è¯è§£é‡Šå’Œç”Ÿæ´»ç±»æ¯”ã€‚
> å¤§ç™½è¯åé¢çš„ **ï¼ˆæ‹¬å·å†…å®¹ï¼‰** æ˜¯å¯¹åº”çš„ä¸“ä¸šæœ¯è¯­ï¼Œæ–¹ä¾¿ä½ å°†ç›´è§‰ç†è§£ä¸æ­£å¼çŸ¥è¯†ä½“ç³»å¯¹æ¥ã€‚

---

## é˜…è¯»æŒ‡å—

**é€‚åˆè°çœ‹**ï¼šå¯¹æ•°æ®ç»“æ„å’Œç®—æ³•æœ‰åŸºæœ¬äº†è§£ï¼ˆçŸ¥é“æ•°ç»„ã€å¾ªç¯ï¼‰ï¼Œæƒ³ç†è§£è¿™ä¸ª Demo åº•å±‚åŸç†çš„å­¦ä¹ è€…ã€‚

**æ€ä¹ˆè¯»**ï¼š
- æ¯ä¸ªçŸ¥è¯†ç‚¹éƒ½æœ‰ã€Œå¤§ç™½è¯ç†è§£ã€å’Œã€Œå¯¹åº”ä»£ç ã€ä¸¤éƒ¨åˆ†
- å¤§ç™½è¯åçš„ **ï¼ˆç²—ä½“æ‹¬å·ï¼‰** æ˜¯ä¸“ä¸šæœ¯è¯­â€”â€”å…ˆç†è§£ç™½è¯ï¼Œå†è®°ä½æœ¯è¯­
- æ–‡æœ«æœ‰æ¨èå­¦ä¹ è·¯å¾„å’Œ LeetCode ç»ƒä¹ é¢˜

**å…¨æ–‡çŸ¥è¯†ç‚¹åœ°å›¾**ï¼š

```
åŸºç¡€æ•°æ®ç»“æ„ï¼ˆç –å¤´ï¼‰                   æ ¸å¿ƒç®—æ³•ï¼ˆå»ºé€ æ–¹æ³•ï¼‰              ç»„åˆåº”ç”¨ï¼ˆå»ºå¥½çš„æˆ¿å­ï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. å­—å…¸ (dict)       â”‚        â”‚ 6. Kahn æ‹“æ‰‘æ’åº    â”‚        â”‚ 10. Super-step å¹¶è¡Œ   â”‚
â”‚ 2. é›†åˆ (set)        â”‚  â”€â”€â”€â†’  â”‚ 7. BFS å¹¿åº¦ä¼˜å…ˆæœç´¢  â”‚  â”€â”€â”€â†’  â”‚ 11. å›¾åˆå¹¶/å±€éƒ¨é‡è§„åˆ’  â”‚
â”‚ 3. æœ‰å‘å›¾ (DAG)      â”‚        â”‚ 8. å°±ç»ªèŠ‚ç‚¹å‘ç°      â”‚        â”‚ 12. TF-IDF æ–‡æœ¬æ£€ç´¢   â”‚
â”‚ 4. å¤šé‡è¾¹            â”‚        â”‚ 9. æœ‰é™çŠ¶æ€æœº (FSM)  â”‚        â”‚ (v3) å›¾è¿è¡Œæ—¶å˜æ›´     â”‚
â”‚ 5. æ ‘ + é˜Ÿåˆ—         â”‚        â”‚                    â”‚        â”‚ (v3) å·¥å…·è·¯ç”±/ç†”æ–­å™¨   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ç›®å½•

- [ä¸€ã€åŸºç¡€æ•°æ®ç»“æ„](#ä¸€åŸºç¡€æ•°æ®ç»“æ„)
  - [1. å­—å…¸ dict â€” ä¸‡èƒ½æŸ¥æ‰¾è¡¨](#1-å­—å…¸-dict--ä¸‡èƒ½æŸ¥æ‰¾è¡¨)
  - [2. é›†åˆ set â€” å»é‡å’Œå¿«é€ŸæŸ¥æ‰¾](#2-é›†åˆ-set--å»é‡å’Œå¿«é€ŸæŸ¥æ‰¾)
  - [3. æœ‰å‘å›¾ â€” èŠ‚ç‚¹å­—å…¸ + è¾¹åˆ—è¡¨](#3-æœ‰å‘å›¾--èŠ‚ç‚¹å­—å…¸--è¾¹åˆ—è¡¨)
  - [4. å¸¦ç±»å‹çš„å¤šé‡è¾¹](#4-å¸¦ç±»å‹çš„å¤šé‡è¾¹)
  - [5. æœ‰æ ¹æ ‘ â€” parent_id çˆ¶æŒ‡é’ˆ](#5-æœ‰æ ¹æ ‘--parentid-çˆ¶æŒ‡é’ˆ)
  - [å¿«ç…§åˆ—è¡¨ â€” Checkpoint æœºåˆ¶](#å¿«ç…§åˆ—è¡¨--checkpoint-æœºåˆ¶)
  - [é˜Ÿåˆ— / åŒç«¯é˜Ÿåˆ— (Deque)](#é˜Ÿåˆ—--åŒç«¯é˜Ÿåˆ—-deque)
- [äºŒã€æ ¸å¿ƒç®—æ³•](#äºŒæ ¸å¿ƒç®—æ³•)
  - [6. Kahn ç®—æ³• (æ‹“æ‰‘æ’åº)](#6-kahn-ç®—æ³•-æ‹“æ‰‘æ’åº)
  - [7. BFS (å¹¿åº¦ä¼˜å…ˆæœç´¢)](#7-bfs-å¹¿åº¦ä¼˜å…ˆæœç´¢)
  - [8. è¿è¡Œæ—¶å°±ç»ªå‘ç°](#8-è¿è¡Œæ—¶å°±ç»ªå‘ç°)
  - [9. æœ‰é™çŠ¶æ€æœº (FSM)](#9-æœ‰é™çŠ¶æ€æœº-fsm)
- [ä¸‰ã€ç»„åˆåº”ç”¨](#ä¸‰ç»„åˆåº”ç”¨)
  - [10. Super-step å¹¶è¡Œæ‰§è¡Œæ¨¡å‹](#10-super-step-å¹¶è¡Œæ‰§è¡Œæ¨¡å‹)
  - [11. å›¾åˆå¹¶ â€” å±€éƒ¨é‡è§„åˆ’](#11-å›¾åˆå¹¶--å±€éƒ¨é‡è§„åˆ’)
  - [12. TF-IDF + ä½™å¼¦ç›¸ä¼¼åº¦](#12-tf-idf--ä½™å¼¦ç›¸ä¼¼åº¦)
- [å››ã€ç®—æ³•è°ƒç”¨å…³ç³»å…¨æ™¯å›¾](#å››ç®—æ³•è°ƒç”¨å…³ç³»å…¨æ™¯å›¾)
- [äº”ã€å­¦ä¹ è·¯å¾„å»ºè®®](#äº”å­¦ä¹ è·¯å¾„å»ºè®®)

---

## ä¸€ã€åŸºç¡€æ•°æ®ç»“æ„

### 1. å­—å…¸ dict â€” ä¸‡èƒ½æŸ¥æ‰¾è¡¨

#### å¤§ç™½è¯ç†è§£

å­—å…¸å°±åƒ**é€šè®¯å½•**ï¼ˆ**å“ˆå¸Œè¡¨ / Hash Table**ï¼‰â€”â€”ä½ çŸ¥é“ä¸€ä¸ªäººçš„åå­—ï¼ˆ**é”® / Key**ï¼‰ï¼Œå°±èƒ½ç«‹åˆ»æ‰¾åˆ°ä»–çš„ç”µè¯å·ç ï¼ˆ**å€¼ / Value**ï¼‰ï¼Œä¸éœ€è¦ä»å¤´ç¿»åˆ°å°¾ã€‚

Python çš„ `dict` å†…éƒ¨ä½¿ç”¨**å“ˆå¸Œè¡¨**ï¼ˆHash Tableï¼‰å®ç°ï¼ŒæŸ¥æ‰¾é€Ÿåº¦å‡ ä¹ä¸å—æ•°æ®é‡å½±å“â€”â€”ä¸ç®¡ä½ é€šè®¯å½•é‡Œæœ‰ 10 ä¸ªäººè¿˜æ˜¯ 10 ä¸‡ä¸ªäººï¼ŒæŸ¥æ‰¾ä¸€ä¸ªäººçš„é€Ÿåº¦å‡ ä¹ä¸€æ ·å¿«ï¼ˆ**å¸¸æ•°æ—¶é—´ O(1)**ï¼‰ã€‚

#### åœ¨ Demo ä¸­çš„ä½¿ç”¨

æ•´ä¸ª Demo æœ€æ ¸å¿ƒçš„ä¸¤ä¸ªå­—å…¸ï¼š

```python
# 1. èŠ‚ç‚¹å­—å…¸ â€” é€šè¿‡èŠ‚ç‚¹ IDï¼ˆKeyï¼‰ç¬é—´æ‰¾åˆ°èŠ‚ç‚¹å¯¹è±¡ï¼ˆValueï¼‰
self.nodes: dict[str, TaskNode] = {
    "goal_1":   TaskNode(...),
    "sub_1":    TaskNode(...),
    "act_1_1":  TaskNode(...),
}
# æŸ¥æ‰¾ act_1_1 â†’ O(1)ï¼ˆå¸¸æ•°æ—¶é—´ï¼‰ï¼Œä¸ç®¡æœ‰å¤šå°‘èŠ‚ç‚¹

# 2. ç»“æœå­—å…¸ â€” é€šè¿‡èŠ‚ç‚¹ IDï¼ˆKeyï¼‰ç¬é—´æ‰¾åˆ°å®ƒçš„æ‰§è¡Œç»“æœï¼ˆValueï¼‰
node_results: dict[str, str] = {
    "act_1_1": "æœç´¢åˆ°äº† Python å¹¶å‘ç›¸å…³èµ„æ–™...",
    "act_1_2": "ä»£ç è¿è¡Œç»“æœ: fibonacci(10) = 55",
}
```

**ä»£ç ä½ç½®**ï¼š`dag/graph.py` â€” `TaskDAG.__init__()` / `schema.py` â€” `DAGState`

#### é€Ÿåº¦å¯¹æ¯”

| æ“ä½œ | dictï¼ˆå“ˆå¸Œè¡¨ / Hash Tableï¼‰ | listï¼ˆæ•°ç»„ / Arrayï¼‰ |
|------|---------------------------|---------------------|
| é€šè¿‡ key æŸ¥æ‰¾ | **O(1)** ç¬é—´æ‰¾åˆ° | O(n) ä»å¤´ç¿»åˆ°å°¾ |
| åˆ¤æ–­ key æ˜¯å¦å­˜åœ¨ | **O(1)** | O(n) |

> **O(1)**ï¼ˆè¯»ä½œã€Œå¤§ O 1ã€ï¼Œ**å¸¸æ•°æ—¶é—´å¤æ‚åº¦**ï¼‰â€”â€” ä¸ç®¡æ•°æ®å¤šå¤§ï¼Œç”¨æ—¶åŸºæœ¬ä¸å˜ï¼ŒåƒæŸ¥å­—å…¸ç›´æ¥ç¿»åˆ°é‚£ä¸€é¡µã€‚
>
> **O(n)**ï¼ˆè¯»ä½œã€Œå¤§ O nã€ï¼Œ**çº¿æ€§æ—¶é—´å¤æ‚åº¦**ï¼‰â€”â€” æ•°æ®é‡ç¿»å€ï¼Œç”¨æ—¶ä¹Ÿç¿»å€ï¼Œåƒä¸€è¡Œä¸€è¡Œæ‰¾ã€‚

---

### 2. é›†åˆ set â€” å»é‡å’Œå¿«é€ŸæŸ¥æ‰¾

#### å¤§ç™½è¯ç†è§£

é›†åˆå°±åƒä¸€ä¸ª**ç­¾åˆ°è¡¨**ï¼ˆ**å“ˆå¸Œé›†åˆ / Hash Set**ï¼‰â€”â€”åªè®°å½•"è°æ¥è¿‡"ï¼ˆ**å…ƒç´ å”¯ä¸€æ€§ / Uniqueness**ï¼‰ï¼Œä¸å…³å¿ƒæ¥äº†å‡ æ¬¡ï¼Œä¹Ÿä¸å…³å¿ƒé¡ºåºï¼ˆ**æ— åº / Unordered**ï¼‰ã€‚æœ€å¤§çš„ä¼˜ç‚¹ï¼šæŸ¥ã€ŒæŸäººæ˜¯å¦æ¥è¿‡ã€éå¸¸å¿«ï¼ˆ**O(1) å¸¸æ•°æ—¶é—´**ï¼‰ã€‚

#### åœ¨ Demo ä¸­çš„ä½¿ç”¨

**ç”¨é€” 1 â€” BFS ä¸­çš„å·²è®¿é—®è®°å½•**ï¼ˆ**é˜²æ­¢é‡å¤è®¿é—® / Cycle Prevention**ï¼‰ï¼š

```python
# dag/graph.py â€” get_downstream()
visited: set[str] = set()    # ç­¾åˆ°è¡¨ï¼ˆvisited é›†åˆï¼‰ï¼šè®°å½•å“ªäº›èŠ‚ç‚¹å·²ç»çœ‹è¿‡äº†
while queue:
    nid = queue.popleft()
    if nid in visited:        # è¿™ä¸ªèŠ‚ç‚¹ç­¾è¿‡åˆ°äº†ï¼Ÿè·³è¿‡ï¼ï¼ˆO(1) æŸ¥è¯¢ï¼‰
        continue
    visited.add(nid)          # ç­¾åˆ°ï¼ˆO(1) æ’å…¥ï¼‰
```

**ç”¨é€” 2 â€” è¾¹å»é‡**ï¼ˆ**å»é‡ / Deduplication**ï¼Œé˜²æ­¢é‡å¤çš„è¾¹å¹²æ‰°ç®—æ³•ï¼‰ï¼š

```python
# agents/planner.py â€” _parse_dag()
seen: set[tuple] = set()      # ç”¨ set å»é‡ï¼Œåˆ©ç”¨å…ƒç´ å”¯ä¸€æ€§
unique_edges = []
for e in edges:
    key = (e.source, e.target, e.edge_type.value)  # æ„é€ å”¯ä¸€æ ‡è¯†ï¼ˆå¤åˆé”® / Composite Keyï¼‰
    if key not in seen:        # O(1) åˆ¤é‡
        seen.add(key)
        unique_edges.append(e)
```

**ç”¨é€” 3 â€” çŠ¶æ€æœºçš„åˆæ³•è½¬ç§»é›†**ï¼ˆ**åˆæ³•çŠ¶æ€é›†åˆ / Valid State Set**ï¼‰ï¼š

```python
# dag/state_machine.py
NodeStatus.PENDING: {NodeStatus.READY, NodeStatus.SKIPPED}
# â†‘ setï¼ŒæŸ¥"èƒ½ä¸èƒ½è½¬ç§»åˆ° READY" â†’ O(1)ï¼ˆé›†åˆçš„ in æ“ä½œï¼‰
```

---

### 3. æœ‰å‘å›¾ â€” èŠ‚ç‚¹å­—å…¸ + è¾¹åˆ—è¡¨

#### å¤§ç™½è¯ç†è§£

**å›¾**ï¼ˆ**Graph**ï¼‰å°±åƒä¸€å¼ åŸå¸‚åœ°å›¾ï¼š

- **èŠ‚ç‚¹**ï¼ˆ**Vertex / Nodeï¼Œé¡¶ç‚¹**ï¼‰= åŸå¸‚ï¼ˆæ¯”å¦‚åŒ—äº¬ã€ä¸Šæµ·ã€å¹¿å·ï¼‰
- **è¾¹**ï¼ˆ**Edgeï¼Œè¾¹**ï¼‰= åŸå¸‚ä¹‹é—´çš„è·¯ï¼ˆæ¯”å¦‚åŒ—äº¬â†’ä¸Šæµ·çš„é«˜é“ï¼‰
- **æœ‰å‘**ï¼ˆ**Directed**ï¼‰= è·¯æ˜¯å•è¡Œé“ï¼ˆåŒ—äº¬â†’ä¸Šæµ· â‰  ä¸Šæµ·â†’åŒ—äº¬ï¼‰
- **æ— ç¯**ï¼ˆ**Acyclic**ï¼‰= ä¸èƒ½ç»•ä¸€åœˆå›åˆ°èµ·ç‚¹ï¼ˆä¸èƒ½ Aâ†’Bâ†’Câ†’Aï¼‰

åˆåœ¨ä¸€èµ·å°±æ˜¯ **DAG**ï¼ˆ**Directed Acyclic Graphï¼Œæœ‰å‘æ— ç¯å›¾**ï¼‰ã€‚

åœ¨è¿™ä¸ª Demo é‡Œï¼š
- èŠ‚ç‚¹ï¼ˆNodeï¼‰= æ¯ä¸ªä»»åŠ¡ï¼ˆæœç´¢èµ„æ–™ã€å†™ä»£ç ã€è·‘æµ‹è¯•ï¼‰
- è¾¹ï¼ˆEdgeï¼‰= ä»»åŠ¡ä¹‹é—´çš„å…ˆåå…³ç³»ï¼ˆå…ˆæœç´¢èµ„æ–™ï¼Œæ‰èƒ½å†™åˆ†ææŠ¥å‘Šï¼‰

#### å›¾æœ‰ä¸‰ç§å¸¸è§å­˜å‚¨æ–¹å¼

æƒ³è±¡ä½ è¦åœ¨ç”µè„‘é‡Œå­˜å‚¨ä¸€å¼  5 ä¸ªåŸå¸‚çš„åœ°å›¾ï¼š

| å­˜å‚¨æ–¹å¼ | å¤§ç™½è¯ | ç©ºé—´å¤æ‚åº¦ | æŸ¥"åŒ—äº¬çš„é‚»å±…" | Demo é€‰æ‹© |
|----------|--------|-----------|---------------|----------|
| **é‚»æ¥çŸ©é˜µ**ï¼ˆAdjacency Matrixï¼‰ | ä¸€å¼  5Ã—5 çš„è¡¨æ ¼ï¼Œæ ¼å­é‡Œå¡«"æœ‰è·¯/æ²¡è·¯" | O(VÂ²) | O(V) æ‰«ä¸€æ•´è¡Œ | âŒ |
| **é‚»æ¥è¡¨**ï¼ˆAdjacency Listï¼‰ | æ¯ä¸ªåŸå¸‚æŒ‚ä¸€ä¸ª"é‚»å±…åˆ—è¡¨" | O(V+E) | O(å‡ºåº¦) ç›´æ¥çœ‹åˆ—è¡¨ | âŒ |
| **è¾¹åˆ—è¡¨**ï¼ˆEdge Listï¼‰ | æŠŠæ‰€æœ‰è·¯å†™æˆä¸€ä¸ªæ¸…å• | O(E) | O(E) ç¿»æ•´ä¸ªæ¸…å• | âœ… ä»£ç æœ€ç®€å• |

> V = èŠ‚ç‚¹æ•°ï¼ˆVertex countï¼‰ï¼ŒE = è¾¹æ•°ï¼ˆEdge countï¼‰ï¼Œå‡ºåº¦ï¼ˆOut-degreeï¼‰= ä¸€ä¸ªèŠ‚ç‚¹æœ‰å‡ æ¡å‡ºå»çš„è¾¹

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`dag/graph.py` â€” `TaskDAG.__init__()`

```python
def __init__(self, task, nodes, edges, context=""):
    self.nodes = nodes    # dictï¼ˆå“ˆå¸Œè¡¨ï¼‰ï¼šèŠ‚ç‚¹å­—å…¸ï¼ŒO(1) éšæœºè®¿é—®
    self.edges = edges    # listï¼ˆåˆ—è¡¨ï¼‰ï¼šè¾¹åˆ—è¡¨ï¼Œéå† O(E)
    self.state = DAGState(task=task, context=context)
```

æŸ¥æ‰¾æŸä¸ªèŠ‚ç‚¹çš„ä¾èµ–ï¼ˆ**å…¥è¾¹æŸ¥è¯¢ / Inbound Edge Query**ï¼‰â€”â€”éœ€è¦ç¿»æ•´ä¸ªè¾¹åˆ—è¡¨è¿‡æ»¤ï¼š

```python
def get_dependency_ids(self, node_id: str) -> list[str]:
    return [
        e.source for e in self.edges              # ç¿»éæ‰€æœ‰è¾¹ O(E)
        if e.target == node_id                     # æ‰¾æŒ‡å‘æˆ‘çš„è¾¹ï¼ˆå…¥è¾¹ / Inbound Edgeï¼‰
        and e.edge_type == EdgeType.DEPENDENCY     # ä¸”æ˜¯ä¾èµ–ç±»å‹çš„
    ]
```

> **ä¸ºä»€ä¹ˆé€‰è¾¹åˆ—è¡¨ï¼Ÿ** Demo çš„èŠ‚ç‚¹å’Œè¾¹ä¸€èˆ¬åªæœ‰å‡ åä¸ªï¼ˆ**å°è§„æ¨¡å›¾ / Small-scale Graph**ï¼‰ï¼Œç¿»æ•´ä¸ªæ¸…å•ä¹Ÿå¾ˆå¿«ã€‚å°±åƒä½ åªæœ‰ 10 ä¸ªå¥½å‹ï¼Œç¿»é€šè®¯å½•å’ŒæŸ¥å­—å…¸å·®åˆ«ä¸å¤§ã€‚å¦‚æœèŠ‚ç‚¹ä¸Šç™¾ï¼Œå¯ä»¥åœ¨åˆå§‹åŒ–æ—¶é¢„å»ºé‚»æ¥è¡¨ï¼ˆAdjacency Listï¼‰ä¼˜åŒ–åˆ° O(å‡ºåº¦)ã€‚

---

### 4. å¸¦ç±»å‹çš„å¤šé‡è¾¹

#### å¤§ç™½è¯ç†è§£

æ™®é€šåœ°å›¾ä¸Šï¼Œä¸¤ä¸ªåŸå¸‚ä¹‹é—´åªæœ‰ä¸€æ¡è·¯ï¼ˆ**ç®€å•å›¾ / Simple Graph**ï¼‰ã€‚ä½†åœ¨è¿™ä¸ª Demo é‡Œï¼Œä¸¤ä¸ªä»»åŠ¡ä¹‹é—´å¯ä»¥æœ‰**å¤šç§ä¸åŒå…³ç³»**â€”â€”å½¢æˆ**å¤šé‡å›¾**ï¼ˆ**Multigraph / Labeled Multigraphï¼Œæœ‰æ ‡ç­¾çš„å¤šé‡æœ‰å‘å›¾**ï¼‰ã€‚å°±åƒåŒ—äº¬å’Œä¸Šæµ·ä¹‹é—´æ—¢æœ‰é«˜é“ï¼ˆä¾èµ–å…³ç³»ï¼‰ï¼Œåˆæœ‰èˆªç­ï¼ˆæ¡ä»¶å…³ç³»ï¼‰ï¼Œè¿˜æœ‰é€€ç¥¨æ¸ é“ï¼ˆå›æ»šå…³ç³»ï¼‰ã€‚

#### ä¸‰ç§è¾¹ç±»å‹ï¼ˆEdge Typesï¼‰

**ä»£ç ä½ç½®**ï¼š`schema.py` â€” `EdgeType`

```python
class EdgeType(str, Enum):
    DEPENDENCY = "dependency"    # ä¾èµ–è¾¹ï¼š"æˆ‘åšå®Œä½ æ‰èƒ½åš"ï¼ˆå‰ç½®ä¾èµ– / Prerequisiteï¼‰
    CONDITIONAL = "conditional"  # æ¡ä»¶è¾¹ï¼š"æˆ‘åšå®Œï¼Œçœ‹ç»“æœå†å†³å®šä½ åšä¸åš"ï¼ˆæ¡ä»¶åˆ†æ”¯ / Conditional Branchï¼‰
    ROLLBACK = "rollback"        # å›æ»šè¾¹ï¼š"æˆ‘å¤±è´¥äº†ï¼Œä½ æ¥å–„å"ï¼ˆå›æ»šæœºåˆ¶ / Rollback Mechanismï¼‰
```

**å…³é”®è®¾è®¡**ï¼šä¸åŒçš„ç®—æ³•åªå…³æ³¨ä¸åŒç±»å‹çš„è¾¹ï¼ˆ**æŒ‰ç±»å‹è¿‡æ»¤éå† / Type-filtered Traversal**ï¼‰ã€‚

| æˆ‘åœ¨åšä»€ä¹ˆ | åªçœ‹å“ªç§è¾¹ | ç±»æ¯” | ä¸“ä¸šæœ¯è¯­ |
|-----------|-----------|------|---------|
| ç®—æ‰§è¡Œé¡ºåº | DEPENDENCY | åªçœ‹ã€Œè°å…ˆè°åã€ | æ‹“æ‰‘æ’åºï¼ˆTopological Sortï¼‰ |
| æ‰¾è°èƒ½æ‰§è¡Œäº† | DEPENDENCY | åªæ£€æŸ¥ã€Œå‰ç½®ä»»åŠ¡åšå®Œäº†å—ã€ | çº¦æŸæ»¡è¶³ï¼ˆConstraint Satisfactionï¼‰ |
| å†³å®šåˆ†æ”¯èµ°ä¸èµ° | CONDITIONAL | åªçœ‹ã€Œæ¡ä»¶è¾¹çš„ç»“æœã€ | æ¡ä»¶è¯„ä¼°ï¼ˆCondition Evaluationï¼‰ |
| å¤±è´¥åè°æ¥å–„å | ROLLBACK | åªçœ‹ã€Œå–„åæ–¹æ¡ˆã€ | å›æ»šæŸ¥æ‰¾ï¼ˆRollback Lookupï¼‰ |
| æ‰¾ä¸‹æ¸¸å­æ ‘ | DEPENDENCY | åªé¡ºç€ã€Œä¾èµ–æ–¹å‘ã€å¾€ä¸‹æ‰¾ | å¯è¾¾æ€§åˆ†æï¼ˆReachability Analysisï¼‰ |

---

### 5. æœ‰æ ¹æ ‘ â€” parent_id çˆ¶æŒ‡é’ˆ

#### å¤§ç™½è¯ç†è§£

å…¬å¸çš„ç»„ç»‡æ¶æ„å°±æ˜¯ä¸€æ£µ**æ ‘**ï¼ˆ**Rooted Treeï¼Œæœ‰æ ¹æ ‘**ï¼‰â€”â€”æ¯ä¸ªäººåªæœ‰**ä¸€ä¸ªç›´å±ä¸Šçº§**ï¼ˆ**çˆ¶èŠ‚ç‚¹ / Parent Node**ï¼‰ï¼Œä½†å¯ä»¥æœ‰å¤šä¸ªä¸‹å±ï¼ˆ**å­èŠ‚ç‚¹ / Child Node**ï¼‰ã€‚

åœ¨ Demo é‡Œï¼Œä»»åŠ¡è¢«ç»„ç»‡æˆä¸‰å±‚æ ‘ç»“æ„ï¼ˆ**å±‚çº§ç»“æ„ / Hierarchy**ï¼‰ï¼š
- **Goal**ï¼ˆç›®æ ‡å±‚ï¼‰= CEOï¼ˆ**æ ¹èŠ‚ç‚¹ / Root Node**ï¼‰ï¼Œåªæœ‰ä¸€ä¸ª
- **SubGoal**ï¼ˆå­ç›®æ ‡å±‚ï¼‰= éƒ¨é—¨ç»ç†ï¼ˆ**ä¸­é—´èŠ‚ç‚¹ / Internal Node**ï¼‰ï¼Œæœ‰å¥½å‡ ä¸ª
- **Action**ï¼ˆåŠ¨ä½œå±‚ï¼‰= åŸºå±‚å‘˜å·¥ï¼ˆ**å¶èŠ‚ç‚¹ / Leaf Node**ï¼‰ï¼Œæ˜¯çœŸæ­£å¹²æ´»çš„äºº

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`schema.py` â€” `TaskNode`

```python
class TaskNode(BaseModel):
    id: str
    node_type: NodeType        # ä¸‰ç§è§’è‰²ï¼šGOAL / SUBGOAL / ACTION
    parent_id: str | None      # æˆ‘çš„ä¸Šçº§æ˜¯è°ï¼ˆçˆ¶æŒ‡é’ˆ / Parent Pointerï¼‰
```

è¿™å«**çˆ¶æŒ‡é’ˆè¡¨ç¤ºæ³•**ï¼ˆ**Parent Pointer Representation**ï¼‰â€”â€”æ¯ä¸ªèŠ‚ç‚¹åªè®°ã€Œæˆ‘çš„ä¸Šçº§æ˜¯è°ã€ï¼Œä¸è®°ã€Œæˆ‘æœ‰å“ªäº›ä¸‹å±ã€ã€‚

| æ“ä½œ | é€Ÿåº¦ | ä¸ºä»€ä¹ˆ | ä¸“ä¸šè¯´æ³• |
|------|------|--------|---------|
| æ‰¾æˆ‘çš„ä¸Šçº§ | ç¬é—´ O(1) | ç›´æ¥è¯» `parent_id` | çˆ¶èŠ‚ç‚¹æŸ¥è¯¢ï¼ˆParent Lookupï¼‰ |
| æ‰¾æˆ‘çš„æ‰€æœ‰ä¸‹å± | è¾ƒæ…¢ O(V) | è¦é—®æ‰€æœ‰äººï¼š"ä½ ä¸Šçº§æ˜¯ä¸æ˜¯æˆ‘ï¼Ÿ" | å­èŠ‚ç‚¹æ‰«æï¼ˆChild Scanï¼‰ |

æ‰¾ä¸‹å±çš„ä»£ç ï¼ˆ`dag/executor.py`ï¼‰ï¼š

```python
# æ‰¾ node çš„æ‰€æœ‰ç›´æ¥ä¸‹å±ï¼ˆå­èŠ‚ç‚¹ / Childrenï¼‰
children = [
    n for n in dag.nodes.values()    # æ‰«ææ‰€æœ‰èŠ‚ç‚¹ O(V)
    if n.parent_id == node.id         # ä½ çš„ä¸Šçº§ï¼ˆParentï¼‰æ˜¯æˆ‘å—ï¼Ÿ
]
```

#### ä¸¤ä¸ªç”¨é€”

**ç”¨é€” 1 â€” è‡ªåº•å‘ä¸Šæ±‡æŠ¥**ï¼ˆ**è‡ªåº•å‘ä¸Šèšåˆ / Bottom-up Aggregation**ï¼Œ`_complete_structural_nodes`ï¼‰ï¼šå½“æ‰€æœ‰å‘˜å·¥ï¼ˆå¶èŠ‚ç‚¹ï¼‰éƒ½å®Œæˆäº†ï¼Œè‡ªåŠ¨æ ‡è®°éƒ¨é—¨ç»ç†ï¼ˆä¸­é—´èŠ‚ç‚¹ï¼‰å®Œæˆï¼›æ‰€æœ‰éƒ¨é—¨ç»ç†å®Œæˆäº†ï¼Œè‡ªåŠ¨æ ‡è®° CEOï¼ˆæ ¹èŠ‚ç‚¹ï¼‰å®Œæˆã€‚

**ç”¨é€” 2 â€” å¯è§†åŒ–å±•ç¤º**ï¼ˆ**æ ‘çš„å±‚åºéå† / Level-order Traversal**ï¼Œ`main.py` â€” `_build_dag_tree()`ï¼‰ï¼šåœ¨ç»ˆç«¯ç”»å‡ºæ¼‚äº®çš„æ ‘å½¢ç»“æ„ã€‚

```
æ ¹èŠ‚ç‚¹(Goal)ï¼šåˆ†æ Python å¹¶å‘æ¨¡å‹ (completed)
â”œâ”€â”€ ä¸­é—´èŠ‚ç‚¹(SubGoal)ï¼šæ”¶é›†èµ„æ–™ (completed) conf=0.9 risk=low
â”‚   â”œâ”€â”€ å¶èŠ‚ç‚¹(Action)ï¼šæœç´¢è®ºæ–‡ (completed)
â”‚   â””â”€â”€ å¶èŠ‚ç‚¹(Action)ï¼šæœç´¢åšå®¢ (completed)
â””â”€â”€ ä¸­é—´èŠ‚ç‚¹(SubGoal)ï¼šç¼–å†™æŠ¥å‘Š (running) conf=0.7 risk=medium
    â””â”€â”€ å¶èŠ‚ç‚¹(Action)ï¼šæ’°å†™åˆç¨¿ (running)
```

---

### å¿«ç…§åˆ—è¡¨ â€” Checkpoint æœºåˆ¶

#### å¤§ç™½è¯ç†è§£

å°±åƒæ¸¸æˆé‡Œçš„**å­˜æ¡£**ï¼ˆ**çŠ¶æ€å¿«ç…§ / State Snapshot**ï¼‰â€”â€”æ¯æ‰“å®Œä¸€å…³ï¼ˆ**æ¯ä¸ª Super-step ç»“æŸå**ï¼‰å°±è‡ªåŠ¨ä¿å­˜ï¼Œå¦‚æœåé¢çš„å…³å¡æŒ‚äº†ï¼Œå¯ä»¥è¯»æ¡£å›åˆ°ä¹‹å‰çš„çŠ¶æ€ï¼ˆ**çŠ¶æ€æ¢å¤ / State Recovery**ï¼‰ã€‚

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`dag/graph.py`

```python
class TaskDAG:
    def __init__(self, ...):
        self._checkpoints: list[dict] = []  # å­˜æ¡£åˆ—è¡¨ï¼ˆæœ‰åºå¿«ç…§åˆ—è¡¨ / Ordered Snapshot Listï¼‰

    def save_checkpoint(self) -> None:
        """æ¯å®Œæˆä¸€è½® Super-stepï¼Œè‡ªåŠ¨å­˜ä¸€æ¬¡æ¡£ï¼ˆåºåˆ—åŒ– / Serializationï¼‰"""
        self._checkpoints.append(self.to_dict())  # æŠŠå½“å‰çŠ¶æ€æ‰“åŒ…æˆå­—å…¸å­˜èµ·æ¥
```

`to_dict()` æŠŠæ•´ä¸ª DAGï¼ˆæ‰€æœ‰èŠ‚ç‚¹çš„çŠ¶æ€ã€æ‰€æœ‰æ‰§è¡Œç»“æœï¼‰æ‰“åŒ…æˆä¸€ä¸ª Python å­—å…¸ï¼ˆ**åºåˆ—åŒ– / Serialization**ï¼‰ã€‚

æ•°æ®ç»“æ„ä¸Šå°±æ˜¯ä¸€ä¸ª `list`ï¼ˆ**åˆ—è¡¨ / Array**ï¼‰ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€æ¬¡å®Œæ•´å¿«ç…§ï¼ˆ**Snapshot**ï¼‰ã€‚è¶Šæ–°çš„å¿«ç…§åœ¨è¶Šåé¢ï¼Œç±»ä¼¼**æ—¶é—´çº¿**ï¼ˆ**Append-only Log / è¿½åŠ æ—¥å¿—**ï¼‰ã€‚è¿™ä¹Ÿæ˜¯ LangGraph ç”¨äºã€Œæ—¶é—´æ—…è¡Œè°ƒè¯•ã€ï¼ˆ**Time-travel Debugging**ï¼‰çš„çµæ„Ÿæ¥æºã€‚

---

### é˜Ÿåˆ— / åŒç«¯é˜Ÿåˆ— (Deque)

#### å¤§ç™½è¯ç†è§£

**é˜Ÿåˆ—**ï¼ˆ**Queue**ï¼‰å°±åƒæ’é˜Ÿä¹°å¥¶èŒ¶â€”â€”**å…ˆæ¥çš„å…ˆä¹°ï¼Œåæ¥çš„åä¹°**ï¼ˆ**FIFO / First In First Outï¼Œå…ˆè¿›å…ˆå‡º**ï¼‰ã€‚

Python é‡Œç”¨ `collections.deque`ï¼ˆ**åŒç«¯é˜Ÿåˆ— / Double-ended Queue**ï¼‰è€Œä¸æ˜¯æ™®é€š `list` åšé˜Ÿåˆ—ï¼ŒåŸå› å¾ˆç®€å•ï¼š

| æ“ä½œ | `deque`ï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰ | `list`ï¼ˆæ•°ç»„ï¼‰ |
|------|-------------------|---------------|
| ä»å³è¾¹åŠ å…¥ï¼ˆ`append`ï¼Œ**å…¥é˜Ÿ / Enqueue**ï¼‰ | ç¬é—´ O(1) | ç¬é—´ O(1) |
| ä»å·¦è¾¹å–å‡ºï¼ˆ`popleft`ï¼Œ**å‡ºé˜Ÿ / Dequeue**ï¼‰ | **ç¬é—´ O(1)** | **å¾ˆæ…¢ O(n)**â€”â€”å–èµ°ç¬¬ä¸€ä¸ªåï¼Œåé¢æ‰€æœ‰å…ƒç´ éƒ½è¦å¾€å‰æŒªä¸€ä½ï¼ˆ**æ•°ç»„å¹³ç§» / Array Shift**ï¼‰ |

æƒ³è±¡æ’é˜Ÿï¼š`deque` æ˜¯å–å·æ’é˜Ÿï¼ˆå«åˆ°å·ç›´æ¥èµ°ï¼Œ**O(1) å‡ºé˜Ÿ**ï¼‰ï¼Œ`list` æ˜¯è‚©å¹¶è‚©æ’é˜Ÿï¼ˆå‰é¢èµ°äº†åé¢å…¨éƒ¨å¾€å‰æŒªï¼Œ**O(n) å‡ºé˜Ÿ**ï¼‰ã€‚

BFS å’Œ Kahn ç®—æ³•éƒ½éœ€è¦é¢‘ç¹ã€Œä»å·¦è¾¹å–å‡ºã€ï¼ˆ**å‡ºé˜Ÿæ“ä½œ**ï¼‰ï¼Œæ‰€ä»¥**å¿…é¡»ç”¨ `deque`**ã€‚

---

## äºŒã€æ ¸å¿ƒç®—æ³•

### 6. Kahn ç®—æ³• (æ‹“æ‰‘æ’åº)

#### å¤§ç™½è¯ç†è§£

**åœºæ™¯**ï¼šä½ è¿™å­¦æœŸè¦é€‰ 6 é—¨è¯¾ï¼Œä½†æœ‰äº›è¯¾éœ€è¦å…ˆä¿®è¯¾ï¼ˆ**å‰ç½®ä¾èµ– / Prerequisite**ï¼‰ã€‚æ¯”å¦‚ï¼š

- ã€Œé«˜ç­‰æ•°å­¦ã€æ²¡æœ‰å‰ç½®è¦æ±‚ï¼ˆ**å…¥åº¦=0 / In-degree=0**ï¼‰
- ã€Œçº¿æ€§ä»£æ•°ã€éœ€è¦å…ˆä¿®ã€Œé«˜ç­‰æ•°å­¦ã€ï¼ˆ**å…¥åº¦=1**ï¼‰
- ã€Œæœºå™¨å­¦ä¹ ã€éœ€è¦å…ˆä¿®ã€Œçº¿æ€§ä»£æ•°ã€å’Œã€Œæ¦‚ç‡è®ºã€ï¼ˆ**å…¥åº¦=2**ï¼‰

é—®é¢˜ï¼š**æ€ä¹ˆå®‰æ’é€‰è¯¾é¡ºåºï¼Œä¿è¯æ¯é—¨è¯¾çš„å‰ç½®è¦æ±‚éƒ½å·²ç»ä¿®è¿‡ï¼Ÿ**

è¿™å°±æ˜¯**æ‹“æ‰‘æ’åº**ï¼ˆ**Topological Sort**ï¼‰è¦è§£å†³çš„é—®é¢˜ã€‚Kahn ç®—æ³•çš„æ ¸å¿ƒæ€è·¯éå¸¸ç›´è§‰ï¼š

1. æ‰¾å‡ºæ‰€æœ‰ã€Œæ²¡æœ‰å‰ç½®è¦æ±‚ã€çš„è¯¾ï¼ˆ**å…¥åº¦=0 / In-degree=0**ï¼‰â†’ è¿™äº›å¯ä»¥å…ˆé€‰
2. é€‰å®Œåï¼Œå®ƒä»¬ã€Œè§£é”ã€çš„è¯¾å‰ç½®è¦æ±‚å°‘äº†ä¸€ä¸ªï¼ˆ**å…¥åº¦å‡ä¸€ / Decrement In-degree**ï¼‰
3. å¦‚æœæŸé—¨è¯¾æ‰€æœ‰å‰ç½®è¦æ±‚éƒ½è¢«è§£é”äº†ï¼ˆ**å…¥åº¦é™ä¸º 0**ï¼‰â†’ å®ƒä¹Ÿå¯ä»¥é€‰äº†
4. é‡å¤ï¼Œç›´åˆ°æ‰€æœ‰è¯¾éƒ½è¢«é€‰å®Œ

> **å…¥åº¦**ï¼ˆ**In-degree**ï¼‰= "æœ‰å‡ æ¡è¾¹æŒ‡å‘æˆ‘" = "æœ‰å‡ é—¨å‰ç½®è¯¾"ã€‚å…¥åº¦ä¸º 0 å°±æ˜¯"æ²¡æœ‰å‰ç½®è¦æ±‚ï¼Œéšæ—¶å¯ä»¥ä¿®"ã€‚

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`dag/graph.py` â€” `topological_sort()`

```python
def topological_sort(self) -> list[str]:
    # ç¬¬ 1 æ­¥ï¼šæ•°æ¯ä¸ªèŠ‚ç‚¹çš„"å…¥åº¦"ï¼ˆIn-degreeï¼Œæœ‰å‡ ä¸ªå‰ç½®ä¾èµ–ï¼‰
    in_degree = {nid: 0 for nid in self.nodes}
    for e in self.edges:
        if e.edge_type == EdgeType.DEPENDENCY:
            in_degree[e.target] += 1     # è¿™æ¡è¾¹æŒ‡å‘è°ï¼Œè°çš„å…¥åº¦ï¼ˆIn-degreeï¼‰+1

    # ç¬¬ 2 æ­¥ï¼šæŠŠå…¥åº¦=0ï¼ˆæ²¡æœ‰å‰ç½®ä¾èµ–ï¼‰çš„èŠ‚ç‚¹æ”¾è¿›é˜Ÿåˆ—ï¼ˆQueue / FIFOï¼‰
    queue = deque(nid for nid, deg in in_degree.items() if deg == 0)
    result = []

    # ç¬¬ 3 æ­¥ï¼šä¸æ–­ä»é˜Ÿåˆ—å–èŠ‚ç‚¹ï¼ˆå‡ºé˜Ÿ / Dequeueï¼‰ï¼ŒæŠŠå®ƒ"è§£é”"çš„åç»­èŠ‚ç‚¹å…¥åº¦ -1
    while queue:
        nid = queue.popleft()        # å‡ºé˜Ÿï¼ˆDequeueï¼‰ï¼šå–å‡ºä¸€ä¸ªå¯ä»¥æ‰§è¡Œçš„èŠ‚ç‚¹
        result.append(nid)           # æ”¾å…¥æ‹“æ‰‘åºåˆ—ï¼ˆTopological Orderï¼‰
        for e in self.edges:
            if e.source == nid and e.edge_type == EdgeType.DEPENDENCY:
                in_degree[e.target] -= 1          # åç»­èŠ‚ç‚¹çš„å…¥åº¦ -1ï¼ˆè§£é”ä¸€ä¸ªå‰ç½®è¦æ±‚ï¼‰
                if in_degree[e.target] == 0:       # æ‰€æœ‰å‰ç½®è¦æ±‚éƒ½æ»¡è¶³äº†ï¼ˆå…¥åº¦å½’é›¶ï¼‰ï¼Ÿ
                    queue.append(e.target)          # å…¥é˜Ÿï¼ˆEnqueueï¼‰ï¼šä½ ä¹Ÿå¯ä»¥æ‰§è¡Œäº†ï¼

    # ç¬¬ 4 æ­¥ï¼šç¯æ£€æµ‹ï¼ˆCycle Detectionï¼‰â€”â€”æ²¡æ’å®Œè¯´æ˜æœ‰ç¯ï¼
    if len(result) != len(self.nodes):
        logger.warning("æœ‰ç¯ï¼ä¸æ˜¯åˆæ³•çš„ DAG")
    return result
```

#### å›¾è§£ â€” æ‰‹åŠ¨æ¨¡æ‹Ÿä¸€é

```
åˆå§‹ DAGï¼ˆæ‹¬å·é‡Œæ˜¯å…¥åº¦ / In-degreeï¼‰ï¼š

  goal_1(0) â”€â”€â†’ sub_1(1) â”€â”€â†’ act_1_1(1)
                          â”€â”€â†’ act_1_2(1)
             â”€â”€â†’ sub_2(1) â”€â”€â†’ act_2_1(1)

ç¬¬ 1 æ­¥ï¼šå…¥åº¦=0 çš„å…¥é˜Ÿ â†’ é˜Ÿåˆ— = [goal_1]

ç¬¬ 2 æ­¥ï¼šå‡ºé˜Ÿ goal_1 â†’ æ‹“æ‰‘åºåˆ— = [goal_1]
         sub_1 å…¥åº¦ 1â†’0 âœ… å…¥é˜Ÿï¼ˆå‰ç½®è¦æ±‚è§£é”ï¼‰
         sub_2 å…¥åº¦ 1â†’0 âœ… å…¥é˜Ÿ
         é˜Ÿåˆ— = [sub_1, sub_2]

ç¬¬ 3 æ­¥ï¼šå‡ºé˜Ÿ sub_1 â†’ æ‹“æ‰‘åºåˆ— = [goal_1, sub_1]
         act_1_1 å…¥åº¦ 1â†’0 âœ… å…¥é˜Ÿ
         act_1_2 å…¥åº¦ 1â†’0 âœ… å…¥é˜Ÿ
         é˜Ÿåˆ— = [sub_2, act_1_1, act_1_2]

ç¬¬ 4 æ­¥ï¼šå‡ºé˜Ÿ sub_2 â†’ æ‹“æ‰‘åºåˆ— = [goal_1, sub_1, sub_2]
         act_2_1 å…¥åº¦ 1â†’0 âœ… å…¥é˜Ÿ
         é˜Ÿåˆ— = [act_1_1, act_1_2, act_2_1]

ç¬¬ 5~7 æ­¥ï¼šä¾æ¬¡å‡ºé˜Ÿ â†’ æœ€ç»ˆæ‹“æ‰‘åºåˆ— = [goal_1, sub_1, sub_2, act_1_1, act_1_2, act_2_1]
```

#### é™„å¸¦èƒ½åŠ›ï¼šç¯æ£€æµ‹ï¼ˆCycle Detectionï¼‰

å¦‚æœæœ€ç»ˆç»“æœçš„é•¿åº¦ < èŠ‚ç‚¹æ€»æ•°ï¼Œè¯´æ˜æœ‰äº›èŠ‚ç‚¹çš„å…¥åº¦æ°¸è¿œé™ä¸åˆ° 0â€”â€”å®ƒä»¬äº’ç›¸ç­‰å¾…ï¼Œå½¢æˆäº†**ç¯ / æ­»é”**ï¼ˆ**Cycle / Deadlock**ï¼‰ã€‚æ¯”å¦‚ A ç­‰ Bï¼ŒB ç­‰ Cï¼ŒC ç­‰ Aã€‚

#### é€Ÿåº¦ï¼ˆæ—¶é—´å¤æ‚åº¦ / Time Complexityï¼‰

- **O(V + E)**ï¼šV æ˜¯èŠ‚ç‚¹æ•°ï¼ˆVertex countï¼‰ï¼ŒE æ˜¯è¾¹æ•°ï¼ˆEdge countï¼‰
- å¤§ç™½è¯ï¼šæ¯ä¸ªèŠ‚ç‚¹çœ‹ä¸€éï¼Œæ¯æ¡è¾¹çœ‹ä¸€éï¼Œæ€»å…±å°±è¿™ä¹ˆå¤šæ´»

#### åœ¨ Demo ä¸­çš„ç”¨é€”

- éªŒè¯ LLM è§„åˆ’çš„ DAG ç¡®å®**æ— ç¯**ï¼ˆAcyclicï¼‰
- æµ‹è¯•ä¸­æ–­è¨€æ‰§è¡Œé¡ºåºçš„åˆæ³•æ€§
- å®é™…æ‰§è¡Œæ—¶**ä¸ä½¿ç”¨**è¿™ä¸ªå›ºå®šåºåˆ—ï¼Œè€Œæ˜¯ç”¨ä¸‹é¢çš„ã€Œè¿è¡Œæ—¶å°±ç»ªå‘ç°ã€

---

### 7. BFS (å¹¿åº¦ä¼˜å…ˆæœç´¢)

#### å¤§ç™½è¯ç†è§£

**åœºæ™¯**ï¼šä½ åœ¨å…¬å¸ç¾¤é‡Œå‘äº†ä¸€æ¡æ¶ˆæ¯ï¼Œæƒ³çŸ¥é“è¿™æ¡æ¶ˆæ¯æœ€ç»ˆä¼šä¼ åˆ°å“ªäº›äººï¼ˆ**å¯è¾¾æ€§åˆ†æ / Reachability Analysis**ï¼‰ã€‚

- ä½ ç›´æ¥å‘ç»™äº† A å’Œ Bï¼ˆ**ç¬¬ 1 å±‚ / Level 1**ï¼‰
- A è½¬å‘ç»™äº† Cï¼ŒB è½¬å‘ç»™äº† C å’Œ Dï¼ˆ**ç¬¬ 2 å±‚ / Level 2**ï¼‰
- C è½¬å‘ç»™äº† Eï¼ˆ**ç¬¬ 3 å±‚ / Level 3**ï¼‰

BFSï¼ˆ**Breadth-First Searchï¼Œå¹¿åº¦ä¼˜å…ˆæœç´¢**ï¼‰å°±æ˜¯è¿™ä¸ªè¿‡ç¨‹â€”â€”**ä¸€å±‚ä¸€å±‚å¾€å¤–æ‰©æ•£**ï¼ˆ**å±‚åºéå† / Level-order Traversal**ï¼‰ï¼Œåƒå¾€æ°´é‡Œæ‰”çŸ³å¤´æ¿€èµ·çš„æ¶Ÿæ¼ªï¼ˆ**æ³¢å‰æ¨è¿› / Wavefront Propagation**ï¼‰ã€‚

åœ¨ Demo é‡Œï¼ŒBFS ç”¨æ¥å›ç­”ä¸€ä¸ªå…³é”®é—®é¢˜ï¼š**å¦‚æœæŸä¸ªä»»åŠ¡å¤±è´¥äº†ï¼Œå®ƒåé¢ï¼ˆä¸‹æ¸¸ / Downstreamï¼‰çš„æ‰€æœ‰ä»»åŠ¡æœ‰å“ªäº›ï¼Ÿ**

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`dag/graph.py` â€” `get_downstream()`

```python
def get_downstream(self, node_id: str) -> list[str]:
    visited: set[str] = set()       # visited é›†åˆï¼ˆHash Setï¼‰ï¼šè°å·²ç»æ‰¾è¿‡äº†
    queue: deque[str] = deque()     # BFS é˜Ÿåˆ—ï¼ˆFIFO Queueï¼‰ï¼šæ¥ä¸‹æ¥è¯¥æ‰¾è°

    # å…ˆæ‰¾ç›´æ¥ä¸‹æ¸¸ï¼ˆç›´æ¥åç»§ / Direct Successorï¼‰
    children = [
        e.target for e in self.edges
        if e.source == node_id and e.edge_type == EdgeType.DEPENDENCY
    ]
    queue.extend(children)           # å…¥é˜Ÿï¼ˆEnqueueï¼‰

    # ä¸€å±‚ä¸€å±‚å¾€å¤–æ‰¾ï¼ˆå±‚åºéå† / Level-order Traversalï¼‰
    while queue:
        nid = queue.popleft()        # å‡ºé˜Ÿï¼ˆDequeueï¼‰
        if nid in visited:
            continue                  # å·²ç»æ‰¾è¿‡äº†ï¼Œè·³è¿‡ï¼ˆé˜²æ­¢é‡å¤è®¿é—® / Cycle Preventionï¼‰
        visited.add(nid)             # ç­¾åˆ°ï¼šæ ‡è®°ä¸º"å·²è®¿é—®"ï¼ˆVisitedï¼‰

        # æ‰¾è¿™ä¸ªèŠ‚ç‚¹çš„ä¸‹æ¸¸ï¼ˆåç»§èŠ‚ç‚¹ / Successorï¼‰ï¼Œç»§ç»­å…¥é˜Ÿ
        for e in self.edges:
            if e.source == nid and e.edge_type == EdgeType.DEPENDENCY:
                queue.append(e.target)

    return list(visited)             # æ‰€æœ‰å¯è¾¾èŠ‚ç‚¹ï¼ˆReachable Nodesï¼‰
```

#### å›¾è§£

```
å‡è®¾ [è¿è¡Œä»£ç ] å¤±è´¥äº†ï¼Œéœ€è¦æ‰¾å‡ºæ‰€æœ‰ä¸‹æ¸¸ï¼ˆDownstreamï¼‰ï¼š

  [è¿è¡Œä»£ç ] â”€â”€â†’ [æ•´ç†æ•°æ®] â”€â”€â†’ [ç”»å›¾è¡¨]
              â”€â”€â†’ [å†™æ—¥å¿—]   â”€â”€â†’ [ç”»å›¾è¡¨]

BFS è¿‡ç¨‹ï¼ˆä¸€å±‚ä¸€å±‚æ‰©æ•£ï¼‰ï¼š
  åˆå§‹é˜Ÿåˆ—: [æ•´ç†æ•°æ®, å†™æ—¥å¿—]       â† Level 1ï¼ˆç›´æ¥åç»§ï¼‰

  å‡ºé˜Ÿã€Œæ•´ç†æ•°æ®ã€â†’ visited={æ•´ç†æ•°æ®} â†’ ä¸‹æ¸¸ã€Œç”»å›¾è¡¨ã€â†’ å…¥é˜Ÿ
  å‡ºé˜Ÿã€Œå†™æ—¥å¿—ã€  â†’ visited={æ•´ç†æ•°æ®, å†™æ—¥å¿—} â†’ ä¸‹æ¸¸ã€Œç”»å›¾è¡¨ã€â†’ å·²åœ¨ visited ä¸­
  å‡ºé˜Ÿã€Œç”»å›¾è¡¨ã€  â†’ visited={æ•´ç†æ•°æ®, å†™æ—¥å¿—, ç”»å›¾è¡¨} â†’ æ— ä¸‹æ¸¸

  ç»“æœï¼ˆæ‰€æœ‰å¯è¾¾èŠ‚ç‚¹ï¼‰: {æ•´ç†æ•°æ®, å†™æ—¥å¿—, ç”»å›¾è¡¨}
  â†’ å…¨éƒ¨æ ‡è®°ä¸º SKIPPEDï¼ˆçº§è”è·³è¿‡ / Cascade Skipï¼‰
```

#### é€Ÿåº¦ï¼ˆæ—¶é—´å¤æ‚åº¦ï¼‰

- **O(V + E)**ï¼šè·Ÿæ‹“æ‰‘æ’åºä¸€æ ·ï¼Œæ¯ä¸ªèŠ‚ç‚¹å’Œæ¯æ¡è¾¹å„çœ‹ä¸€é

#### åœ¨ Demo ä¸­çš„ç”¨é€”

1. **çº§è”è·³è¿‡**ï¼ˆ**Cascade Skip**ï¼Œ`mark_subtree_skipped`ï¼‰ï¼šä»»åŠ¡å¤±è´¥æ—¶ï¼Œæ‰¾å‡ºæ‰€æœ‰ä¸‹æ¸¸ï¼ˆDownstreamï¼‰å¹¶å…¨éƒ¨è·³è¿‡
2. **å±€éƒ¨é‡è§„åˆ’**ï¼ˆ**Partial Replanning**ï¼Œ`_merge_dags`ï¼‰ï¼šç¡®å®šéœ€è¦æ›¿æ¢çš„å­æ ‘èŒƒå›´

#### BFS vs DFS ä¸ºä»€ä¹ˆé€‰ BFSï¼Ÿ

å…¶å®è¿™é‡Œç”¨ BFSï¼ˆ**å¹¿åº¦ä¼˜å…ˆ / Breadth-First**ï¼‰å’Œ DFSï¼ˆ**æ·±åº¦ä¼˜å…ˆ / Depth-First**ï¼‰éƒ½èƒ½å¾—åˆ°ç›¸åŒç»“æœâ€”â€”éƒ½æ˜¯æ±‚ã€Œä»æŸä¸ªèŠ‚ç‚¹å‡ºå‘èƒ½åˆ°è¾¾çš„æ‰€æœ‰èŠ‚ç‚¹ã€ï¼ˆ**å¯è¾¾æ€§åˆ†æ / Reachability**ï¼‰ã€‚Demo é€‰ BFS ä¸»è¦å› ä¸ºå®ƒçš„è¡Œä¸ºæ›´ç›´è§‚ï¼ˆä¸€å±‚ä¸€å±‚æ‰©æ•£ï¼‰ï¼Œä»£ç ä¹Ÿæ›´ç®€å•ï¼ˆç”¨é˜Ÿåˆ—å³å¯ï¼Œä¸éœ€è¦é€’å½’ï¼‰ã€‚

---

### 8. è¿è¡Œæ—¶å°±ç»ªå‘ç°

#### å¤§ç™½è¯ç†è§£

è¿™æ˜¯ Demo ä¸­**æœ€é‡è¦çš„ç®—æ³•**â€”â€”å®ƒå†³å®šäº†æ¯ä¸€è½®æ‰§è¡Œè°ã€‚

æƒ³è±¡ä½ æ˜¯ä¸€ä¸ªå›¢é˜Ÿ leaderï¼Œæ¯å¤©æ—©ä¸Šç«™ä¼šï¼ˆ**æ¯ä¸ª Super-step å¼€å§‹æ—¶**ï¼‰ï¼š
1. æ‰«ä¸€çœ¼æ‰€æœ‰å¾…åŠä»»åŠ¡ï¼ˆ**éå†æ‰€æœ‰èŠ‚ç‚¹ / Node Traversal**ï¼‰
2. å¯¹æ¯ä¸ªä»»åŠ¡é—®ä¸€å¥ï¼š"ä½ ä¾èµ–çš„å‰ç½®ä»»åŠ¡éƒ½åšå®Œäº†å—ï¼Ÿ"ï¼ˆ**çº¦æŸæ»¡è¶³æ£€æŸ¥ / Constraint Satisfaction Check**ï¼‰
3. "éƒ½åšå®Œäº†" â†’ ä»Šå¤©å¼€å§‹åšï¼ï¼ˆ**å°±ç»ª / Ready**ï¼‰
4. "è¿˜æ²¡å‘¢" â†’ ç»§ç»­ç­‰ï¼ˆ**é˜»å¡ / Blocked**ï¼‰

```
æ¯å¤©æ—©ä¸Šéƒ½é‡æ–°é—®ä¸€éï¼ˆåŠ¨æ€è°ƒåº¦ / Dynamic Schedulingï¼‰ï¼Œ
è€Œä¸æ˜¯ä¸€å¼€å§‹å°±æŠŠæ‰€æœ‰æ—¥æœŸæ’å¥½ï¼ˆé™æ€è°ƒåº¦ / Static Schedulingï¼‰ã€‚
```

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`dag/graph.py` â€” `get_ready_nodes()`

```python
def get_ready_nodes(self) -> list[TaskNode]:
    eligible = {NodeStatus.PENDING, NodeStatus.READY}  # å€™é€‰é›†ï¼šè¿˜æ²¡å¼€å§‹åšçš„
    ready = []
    for node in self.nodes.values():        # éå†æ‰€æœ‰èŠ‚ç‚¹ï¼ˆNode Traversalï¼‰
        if node.status not in eligible:
            continue                         # å·²ç»åšäº†/å¤±è´¥äº†/è·³è¿‡äº†ï¼Œä¸ç®¡
        deps = self.get_dependency_ids(node.id)  # æŸ¥å…¥è¾¹ï¼ˆInbound Edgeï¼‰ï¼šæˆ‘ä¾èµ–è°ï¼Ÿ
        # çº¦æŸæ»¡è¶³æ£€æŸ¥ï¼ˆConstraint Satisfactionï¼‰ï¼šæˆ‘çš„æ‰€æœ‰å‰ç½®ä¾èµ–éƒ½å®Œæˆäº†å—ï¼Ÿ
        if all(self.nodes[d].status == NodeStatus.COMPLETED for d in deps):
            ready.append(node)               # çº¦æŸæ»¡è¶³ â†’ æˆ‘å°±ç»ªäº†ï¼ˆReadyï¼‰ï¼
    return ready
```

#### å’Œæ‹“æ‰‘æ’åºçš„å…³ç³»

å®ƒä»¬æ˜¯è§£å†³åŒä¸€ä¸ªé—®é¢˜ï¼ˆ**ä»»åŠ¡è°ƒåº¦ / Task Scheduling**ï¼‰çš„ä¸¤ç§æ–¹å¼ï¼š

| | Kahn æ‹“æ‰‘æ’åº | è¿è¡Œæ—¶å°±ç»ªå‘ç° |
|--|--------------|--------------|
| ä»€ä¹ˆæ—¶å€™ç®— | ä¸€æ¬¡ç®—å®Œï¼ˆ**ç¦»çº¿ç®—æ³• / Offline Algorithm**ï¼‰ | æ¯è½®ç°åœºç®—ï¼ˆ**åœ¨çº¿ç®—æ³• / Online Algorithm**ï¼‰ |
| éœ€è¦ä»€ä¹ˆä¿¡æ¯ | åªçœ‹å›¾ç»“æ„ï¼ˆ**é™æ€ä¿¡æ¯**ï¼‰ | çœ‹å›¾ç»“æ„ + **å½“å‰è¿è¡Œæ—¶çŠ¶æ€** |
| èƒ½å¦åº”å¯¹å¤±è´¥ï¼Ÿ | ä¸èƒ½â€”â€”æ’å®Œäº†å°±æ˜¯å›ºå®šçš„ | **èƒ½**â€”â€”å¤±è´¥èŠ‚ç‚¹è¢«è·³è¿‡ï¼Œä¸‹ä¸€è½®è‡ªåŠ¨è°ƒæ•´ |
| ç±»æ¯” | å¼€å­¦å‰æ’å¥½æ•´å­¦æœŸè¯¾è¡¨ | æ¯å¤©æ—©ä¸Šçœ‹å“ªäº›è¯¾èƒ½ä¸Š |
| ä¸“ä¸šæœ¯è¯­ | é™æ€è°ƒåº¦ï¼ˆStatic Schedulingï¼‰ | åŠ¨æ€è°ƒåº¦ï¼ˆDynamic Schedulingï¼‰ |

> ä½ å¯ä»¥æŠŠã€Œè¿è¡Œæ—¶å°±ç»ªå‘ç°ã€ç†è§£ä¸º Kahn ç®—æ³•çš„**åŠ¨æ€ç‰ˆæœ¬**ï¼ˆ**Online Kahn**ï¼‰â€”â€”æ¯è½®åªåš Kahn çš„ç¬¬ä¸€æ­¥ï¼ˆæ‰¾å…¥åº¦=0 çš„èŠ‚ç‚¹ï¼‰ï¼Œç„¶åç­‰è¿™æ‰¹åšå®Œï¼Œå†æ‰¾ä¸‹ä¸€æ‰¹ã€‚

---

### 9. æœ‰é™çŠ¶æ€æœº (FSM)

#### å¤§ç™½è¯ç†è§£

**åœºæ™¯**ï¼šæƒ³è±¡ä¸€ä¸ªç½‘è´­è®¢å•çš„çŠ¶æ€å˜åŒ–ï¼ˆ**çŠ¶æ€ç”Ÿå‘½å‘¨æœŸ / State Lifecycle**ï¼‰ï¼š

```
å¾…ä»˜æ¬¾ â†’ å·²ä»˜æ¬¾ â†’ å·²å‘è´§ â†’ å·²ç­¾æ”¶
                         â†’ é€€è´§ä¸­ â†’ å·²é€€æ¬¾
```

ä½ ä¸èƒ½è®©ä¸€ä¸ªã€Œå·²ç­¾æ”¶ã€çš„è®¢å•ç›´æ¥è·³åˆ°ã€Œå¾…ä»˜æ¬¾ã€â€”â€”è¿™ä¸åˆé€»è¾‘ï¼ˆ**éæ³•è½¬ç§» / Invalid Transition**ï¼‰ã€‚**æœ‰é™çŠ¶æ€æœº**ï¼ˆ**FSM / Finite State Machine**ï¼‰å°±æ˜¯**å®šä¹‰æ‰€æœ‰åˆæ³•çš„çŠ¶æ€å˜åŒ–è·¯çº¿ï¼ˆè½¬ç§»è¡¨ / Transition Tableï¼‰ï¼Œç¦æ­¢éæ³•æ“ä½œ**ã€‚

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`dag/state_machine.py`

```python
# çŠ¶æ€è½¬ç§»è¡¨ï¼ˆTransition Tableï¼‰â€”â€”ä¸€ç›®äº†ç„¶
VALID_TRANSITIONS = {
    PENDING:     {READY, SKIPPED},       # ç­‰å¾…ä¸­ â†’ å°±ç»ª æˆ– è·³è¿‡
    READY:       {RUNNING, SKIPPED},     # å°±ç»ª â†’ æ‰§è¡Œä¸­ æˆ– è·³è¿‡
    RUNNING:     {COMPLETED, FAILED},    # æ‰§è¡Œä¸­ â†’ æˆåŠŸ æˆ– å¤±è´¥
    FAILED:      {ROLLED_BACK, SKIPPED}, # å¤±è´¥ â†’ å·²å›æ»š æˆ– è·³è¿‡
    COMPLETED:   {},                      # ç»ˆæ€ï¼ˆTerminal Stateï¼‰
    SKIPPED:     {},                      # ç»ˆæ€
    ROLLED_BACK: {},                      # ç»ˆæ€
}
```

æ ¡éªŒé€»è¾‘ï¼ˆ**è½¬ç§»æ ¡éªŒ / Transition Validation**ï¼‰ï¼š

```python
def transition(self, node, new_status):
    # æŸ¥è¡¨ï¼ˆO(1)ï¼Œå› ä¸º set çš„ in æ“ä½œæ˜¯å¸¸æ•°æ—¶é—´ï¼‰
    if not self.can_transition(node, new_status):
        raise InvalidTransitionError(...)   # éæ³•è½¬ç§»ï¼ï¼ˆInvalid Transitionï¼‰
    node.status = new_status                 # åˆæ³•è½¬ç§»ï¼ˆValid Transitionï¼‰â†’ æ”¾è¡Œ
```

#### èŠ‚ç‚¹çš„ã€Œäººç”Ÿè½¨è¿¹ã€â€” çŠ¶æ€è½¬ç§»å›¾ï¼ˆState Transition Diagramï¼‰

```
æ­£å¸¸è·¯çº¿ï¼ˆHappy Pathï¼Œæ­£å¸¸è·¯å¾„ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç­‰å¾…ä¸­(PENDING) â†’ å°±ç»ª(READY) â†’ æ‰§è¡Œä¸­(RUNNING) â†’ æˆåŠŸ(COMPLETED) ğŸ‰ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å¤±è´¥è·¯çº¿ï¼ˆæœ‰å–„å / Rollback Pathï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç­‰å¾…ä¸­ â†’ å°±ç»ª â†’ æ‰§è¡Œä¸­ â†’ å¤±è´¥(FAILED) â†’ å·²å›æ»š(ROLLED_BACK) ğŸ”„       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è·³è¿‡è·¯çº¿ï¼ˆConditional Skip / æ¡ä»¶è·³è¿‡ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç­‰å¾…ä¸­ â†’ è·³è¿‡(SKIPPED) â­ï¸               â”‚ â† å‰é¢æœ‰èŠ‚ç‚¹å¤±è´¥ï¼Œæˆ–æ¡ä»¶ä¸æ»¡è¶³
â”‚  å°±ç»ª â†’ è·³è¿‡ â­ï¸                          â”‚
â”‚  å¤±è´¥ â†’ è·³è¿‡ â­ï¸                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¸‰ä¸ªç»ˆæ€ï¼ˆTerminal State / å¸æ”¶æ€ Absorbing Stateï¼Œåˆ°äº†å°±ä¸èƒ½å†èµ°äº†ï¼‰ï¼š
  æˆåŠŸå®Œæˆ ğŸ‰  |  è·³è¿‡ â­ï¸  |  å·²å›æ»š ğŸ”„
```

#### ä¸ºä»€ä¹ˆéœ€è¦çŠ¶æ€æœºï¼Ÿ

å¦‚æœæ²¡æœ‰çŠ¶æ€æœºä¿æŠ¤ï¼ˆ**çŠ¶æ€ä¸€è‡´æ€§ä¿éšœ / State Consistency Guard**ï¼‰ï¼Œä»£ç å¯èƒ½æ„å¤–åœ°ï¼š
- æŠŠã€Œå·²å®Œæˆã€çš„èŠ‚ç‚¹æ”¹å›ã€Œç­‰å¾…ä¸­ã€â†’ å¯¼è‡´åŒä¸€ä»»åŠ¡è¢«é‡å¤æ‰§è¡Œï¼ˆ**å¹‚ç­‰æ€§ç ´å / Idempotency Violation**ï¼‰
- æŠŠã€Œæ‰§è¡Œä¸­ã€çš„èŠ‚ç‚¹ç›´æ¥æ”¹ä¸ºã€Œå·²å›æ»šã€â†’ è·³è¿‡äº†å¤±è´¥å¤„ç†æµç¨‹ï¼ˆ**é€»è¾‘ä¸ä¸€è‡´ / Inconsistent Logic**ï¼‰

çŠ¶æ€æœºåƒä¸€ä¸ª**äº¤é€šä¿¡å·ç¯æ§åˆ¶å™¨**â€”â€”ç¡®ä¿çº¢ç»¿ç¯åªä¼šæŒ‰ ç»¿â†’é»„â†’çº¢ å¾ªç¯åˆ‡æ¢ï¼ˆ**åˆæ³•è½¬ç§» / Valid Transition**ï¼‰ï¼Œä¸ä¼šçªç„¶ä»ç»¿ç¯è·³åˆ°çº¢ç¯ï¼ˆ**éæ³•è½¬ç§» / Invalid Transition**ï¼‰ã€‚

#### æ•°æ®ç»“æ„è§†è§’

`VALID_TRANSITIONS` æœ¬èº«å°±æ˜¯ä¸€ä¸ª**å°å‹æœ‰å‘å›¾**ï¼ˆ**çŠ¶æ€è½¬ç§»å›¾ / State Transition Graph**ï¼‰ï¼š
- 7 ä¸ªèŠ‚ç‚¹ï¼ˆ7 ç§çŠ¶æ€ / Statesï¼‰
- æ¯æ¡è¾¹ä»£è¡¨ä¸€ä¸ªåˆæ³•è½¬ç§»ï¼ˆ**Transition**ï¼‰
- 3 ä¸ªç»ˆæ€æ²¡æœ‰å‡ºè¾¹ï¼ˆåˆ°äº†å°±èµ°ä¸å‡ºå»äº†ï¼Œå­¦æœ¯ä¸Šå«ã€Œ**å¸æ”¶æ€ / Absorbing State**ã€â€”â€”è¿›å»äº†å°±å‡ºä¸æ¥ï¼Œåƒé»‘æ´ä¸€æ ·ï¼‰

---

## ä¸‰ã€ç»„åˆåº”ç”¨

### 10. Super-step å¹¶è¡Œæ‰§è¡Œæ¨¡å‹

#### å¤§ç™½è¯ç†è§£

æƒ³è±¡ä¸€ä¸ªå¿«é€’åˆ†æ‹£ä¸­å¿ƒï¼ˆ**BSP æ¨¡å‹ / Bulk Synchronous Parallelï¼Œæ‰¹é‡åŒæ­¥å¹¶è¡Œ**ï¼‰ï¼š

1. çœ‹ä¸€çœ¼ä¼ é€å¸¦ï¼šæœ‰å“ªäº›åŒ…è£¹å¯ä»¥åˆ†æ‹£äº†ï¼Ÿï¼ˆ**å°±ç»ªå‘ç° / Ready-Node Discovery**ï¼‰
2. æŠŠèƒ½åˆ†æ‹£çš„åŒ…è£¹åˆ†ç»™å¤šä¸ªå·¥äºº**åŒæ—¶å¤„ç†**ï¼ˆ**å¹¶è¡Œæ‰§è¡Œ / Parallel Execution**ï¼‰
3. ç­‰æ‰€æœ‰å·¥äººéƒ½å¤„ç†å®Œï¼ˆ**åŒæ­¥å±éšœ / Barrier Synchronization**ï¼‰â†’ æ£€æŸ¥ç»“æœï¼Œç™»è®°å…¥åº“ï¼ˆ**ç»“æœåˆå¹¶ / Result Merge**ï¼‰
4. çœ‹çœ‹ä¼ é€å¸¦ä¸Šåˆæœ‰å“ªäº›æ–°åŒ…è£¹å¯ä»¥å¤„ç†äº†ï¼ˆ**ä¸‹ä¸€è½®å°±ç»ªå‘ç°**ï¼‰
5. é‡å¤ï¼Œç›´åˆ°ä¼ é€å¸¦ç©ºäº†ï¼ˆ**æ‰€æœ‰èŠ‚ç‚¹åˆ°è¾¾ç»ˆæ€ / All Terminal**ï¼‰

è¿™ä¸ªã€Œçœ‹ä¸€çœ¼ â†’ ä¸€èµ·å¹² â†’ ç­‰å…¨éƒ¨å®Œæˆ â†’ å†çœ‹ä¸€çœ¼ã€çš„å¾ªç¯ï¼Œæ¯ä¸€è½®å°±æ˜¯ä¸€ä¸ª **Super-step**ï¼ˆæºè‡ª **Pregel å›¾è®¡ç®—æ¡†æ¶** / LangGraphï¼‰ã€‚

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`dag/executor.py` â€” `execute()` ä¸»å¾ªç¯

```python
while not dag.is_complete():                       # ç»ˆæ­¢æ¡ä»¶ï¼šæ‰€æœ‰èŠ‚ç‚¹åˆ°è¾¾ç»ˆæ€
    step += 1
    ready = dag.get_ready_nodes()                   # 1. å°±ç»ªå‘ç°ï¼ˆReady-Node Discoveryï¼‰
    batch = actionable[:self._max_parallel]         # 2. å¹¶å‘åº¦é™æµï¼ˆConcurrency Limitï¼‰
    results = await asyncio.gather(*[               # 3. å¹¶è¡Œæ‰§è¡Œï¼ˆParallel Executionï¼‰
        self._run_node(node, dag) for node in batch
    ])
    # 4. ç»“æœåˆå¹¶ + è´¨é‡éªŒè¯ + å¤±è´¥å¤„ç†ï¼ˆResult Merge + Validation + Error Handlingï¼‰
    for node, result in zip(batch, results):
        dag.state.merge_result(node.id, result.output)  # å†™å…¥å…±äº«çŠ¶æ€ï¼ˆShared Stateï¼‰
        # ... æ£€æŸ¥ exit criteriaï¼ˆå®Œæˆåˆ¤æ®ï¼‰ï¼Œå¤„ç†å¤±è´¥èŠ‚ç‚¹ ...
    # 5. æ¡ä»¶è¯„ä¼° + å°±ç»ªåˆ·æ–° + ä¿å­˜å¿«ç…§ï¼ˆCondition Eval + Refresh + Checkpointï¼‰
    self._process_conditions(dag)
    dag.refresh_ready_states()
    dag.save_checkpoint()                           # æ¯è½®å­˜æ¡£ï¼ˆState Snapshotï¼‰
```

#### å’Œ BFS å±‚åºéå†ï¼ˆLevel-order Traversalï¼‰çš„å…³ç³»

Super-step æœ¬è´¨ä¸Šæ˜¯ BFS çš„ä¸€ç§å˜ä½“â€”â€”æ¯ä¸€è½®å¤„ç†å›¾çš„ã€Œä¸€å±‚ã€ï¼ˆ**Wavefrontï¼Œæ³¢å‰**ï¼‰ï¼š

```
BFS å±‚åºéå†ï¼ˆæŒ‰æ‹“æ‰‘å±‚çº§è®¿é—®èŠ‚ç‚¹ï¼‰ï¼š
  ç¬¬ 0 å±‚(Level 0): [goal_1]
  ç¬¬ 1 å±‚(Level 1): [sub_1, sub_2]
  ç¬¬ 2 å±‚(Level 2): [act_1_1, act_1_2, act_2_1]

Super-step æ‰§è¡Œï¼ˆæŒ‰è½®æ¬¡æ‰§è¡Œä»»åŠ¡ï¼‰ï¼š
  è½®æ¬¡ 1: [goal_1, sub_1, sub_2]       â† ç»“æ„èŠ‚ç‚¹ï¼ˆStructural Nodeï¼‰ç§’å®Œæˆ
  è½®æ¬¡ 2: [act_1_1, act_1_2, act_2_1]  â† è¿™ä¸‰ä¸ªå¹¶è¡Œæ‰§è¡Œï¼ˆParallelï¼‰ï¼
  è½®æ¬¡ 3: [act_summary]                 â† ä¾èµ–ï¼ˆDependencyï¼‰ä¸Šé¢ä¸‰ä¸ªï¼Œæœ€åæ‰èƒ½åš
```

---

### 11. å›¾åˆå¹¶ â€” å±€éƒ¨é‡è§„åˆ’

#### å¤§ç™½è¯ç†è§£

æƒ³è±¡ä½ æ‹¼äº†ä¸€ä¸ª 100 å—çš„æ‹¼å›¾ï¼ˆ**DAG çš„èŠ‚ç‚¹é›†åˆ**ï¼‰ï¼Œæ‹¼åˆ°ç¬¬ 80 å—æ—¶å‘ç°å·¦ä¸‹è§’é‚£ 5 å—æ‹¼é”™äº†ï¼ˆ**å¤±è´¥å­æ ‘ / Failed Subtree**ï¼‰ã€‚

- v1 çš„åšæ³•ï¼šå…¨éƒ¨æ‹†æ‰é‡æ‹¼ï¼ˆ**å…¨é‡é‡è§„åˆ’ / Full Replanning**ï¼‰ğŸ˜«
- v2 çš„åšæ³•ï¼šåªæ‹†æ‰å·¦ä¸‹è§’é‚£ 5 å—ï¼ˆ**å­æ ‘æ›¿æ¢ / Subtree Replacement**ï¼‰ï¼Œå…¶ä»– 75 å—ä¿æŒä¸åŠ¨ï¼ˆ**çŠ¶æ€ä¿ç•™ / State Preservation**ï¼‰ï¼Œç”¨æ–°çš„ 5 å—æ›¿ä¸Šå» ğŸ‘

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`agents/planner.py` â€” `_merge_dags()`

```python
@staticmethod
def _merge_dags(old_dag, new_dag, parent_id):
    merged_nodes = {}

    # 1. ç”¨ BFSï¼ˆå¯è¾¾æ€§åˆ†æ / Reachabilityï¼‰æ‰¾å‡º"å“ª 5 å—æ‹¼é”™äº†"
    failed_subtree = set(old_dag.get_downstream(parent_id)) | {parent_id}

    # 2. ä¿ç•™"æ²¡æ‹¼é”™çš„ 75 å—"ï¼ˆå·®é›† / Set Differenceï¼‰
    for nid, node in old_dag.nodes.items():
        if nid not in failed_subtree or node.status == NodeStatus.COMPLETED:
            merged_nodes[nid] = node

    # 3. æ”¾å…¥"æ–°çš„ 5 å—"ï¼ˆå¹¶é›† / Set Unionï¼‰
    for nid, node in new_dag.nodes.items():
        if nid not in merged_nodes:
            merged_nodes[nid] = node

    # 4. ä¿ç•™ä¹‹å‰çš„æ‰§è¡Œç»“æœï¼ˆçŠ¶æ€ä¿ç•™ / State Preservationï¼‰
    result_dag.state.node_results = dict(old_dag.state.node_results)
```

#### ç®—æ³•æœ¬è´¨ â€” å›¾çš„é›†åˆè¿ç®—ï¼ˆGraph Set Operationsï¼‰

ç”¨å…¬å¼è¡¨ç¤ºå°±æ˜¯ï¼š

```
æ–°å›¾ = (æ—§å›¾ âˆ’ å¤±è´¥å­æ ‘) âˆª é‡è§„åˆ’å­å›¾
        å·®é›†(Difference)   å¹¶é›†(Union)
```

è¿™æ˜¯**å›¾çš„é›†åˆè¿ç®—**ï¼ˆ**Graph Set Operations**ï¼‰â€”â€”å…ˆç”¨ BFS ç¡®å®šè¦æ›¿æ¢çš„èŒƒå›´ï¼ˆ**å­æ ‘è¾¹ç•Œ / Subtree Boundary**ï¼‰ï¼Œå†åšå·®é›†å’Œå¹¶é›†ã€‚

---

### 12. TF-IDF + ä½™å¼¦ç›¸ä¼¼åº¦

#### å¤§ç™½è¯ç†è§£

**åœºæ™¯**ï¼šä½ çš„ç”µè„‘é‡Œæœ‰ 100 ç¯‡è¯»ä¹¦ç¬”è®°ï¼Œç°åœ¨è¦æœç´¢"æœºå™¨å­¦ä¹ çš„æ¢¯åº¦ä¸‹é™"ï¼Œæ€ä¹ˆæ‰¾åˆ°æœ€ç›¸å…³çš„é‚£å‡ ç¯‡ï¼Ÿï¼ˆ**ä¿¡æ¯æ£€ç´¢ / Information Retrieval**ï¼‰

æ ¸å¿ƒæ€æƒ³ï¼š

1. **TFï¼ˆTerm Frequencyï¼Œè¯é¢‘ï¼‰**ï¼šä¸€ä¸ªè¯åœ¨è¿™ç¯‡æ–‡ç« é‡Œå‡ºç°è¶Šå¤šï¼Œè¯´æ˜è¶Šé‡è¦
   - "æ¢¯åº¦"åœ¨æŸç¯‡æ–‡ç« å‡ºç° 10 æ¬¡ â†’ å¯èƒ½å¾ˆç›¸å…³

2. **IDFï¼ˆInverse Document Frequencyï¼Œé€†æ–‡æ¡£é¢‘ç‡ï¼‰**ï¼šä¸€ä¸ªè¯åœ¨è¶Šå°‘çš„æ–‡ç« ä¸­å‡ºç°ï¼Œå®ƒå°±è¶Šã€Œç‹¬ç‰¹ã€ï¼ˆ**åŒºåˆ†åº¦ / Discriminative Power**ï¼‰
   - "çš„"å‡ºç°åœ¨ 99 ç¯‡é‡Œ â†’ æ²¡å•¥ç”¨ï¼Œå¤ªæ™®é€šäº†ï¼ˆ**åœç”¨è¯ / Stop Word**ï¼‰
   - "æ¢¯åº¦"åªå‡ºç°åœ¨ 3 ç¯‡é‡Œ â†’ å¾ˆç‹¬ç‰¹ï¼Œèƒ½åŒºåˆ†æ–‡ç« 

3. **TF-IDF = TF Ã— IDF**ï¼šä¸€ä¸ªè¯**åœ¨å½“å‰æ–‡ç« é¢‘ç¹å‡ºç°**ï¼ˆé«˜ TFï¼‰ï¼ŒåŒæ—¶**åœ¨å…¶ä»–æ–‡ç« å¾ˆå°‘è§**ï¼ˆé«˜ IDFï¼‰â†’ è¿™ä¸ªè¯å¯¹è¿™ç¯‡æ–‡ç« éå¸¸é‡è¦ï¼ˆ**ç‰¹å¾æƒé‡ / Feature Weight**ï¼‰

4. **ä½™å¼¦ç›¸ä¼¼åº¦**ï¼ˆ**Cosine Similarity**ï¼‰ï¼šæŠŠæ–‡ç« å’Œæœç´¢è¯å„å˜æˆä¸€ç»„æ•°å­—ï¼ˆ**å‘é‡ / Vector**ï¼‰ï¼Œç„¶åçœ‹å®ƒä»¬çš„æ–¹å‘æœ‰å¤šæ¥è¿‘ï¼ˆ**å‘é‡å¤¹è§’ / Vector Angle**ï¼‰
   - æ–¹å‘å®Œå…¨ä¸€è‡´ï¼ˆå¤¹è§’=0Â°ï¼‰= 1.0ï¼ˆæœ€ç›¸å…³ï¼‰
   - æ–¹å‘å‚ç›´ï¼ˆå¤¹è§’=90Â°ï¼‰= 0.0ï¼ˆå®Œå…¨ä¸ç›¸å…³ï¼‰

#### å¯¹åº”ä»£ç 

**ä»£ç ä½ç½®**ï¼š`knowledge/retriever.py`

```python
# TFï¼ˆè¯é¢‘ / Term Frequencyï¼‰ï¼šè®¡ç®—æ¯ä¸ªè¯åœ¨æ–‡ç« ä¸­çš„å‡ºç°é¢‘ç‡ï¼Œå½’ä¸€åŒ–åˆ° 0~1
def _compute_tf(text):
    words = re.findall(r"[a-z0-9]+", text.lower())  # åˆ†è¯ï¼ˆTokenizationï¼‰
    freq = {}
    for w in words:
        freq[w] = freq.get(w, 0) + 1
    max_freq = max(freq.values())
    return {w: c / max_freq for w, c in freq.items()}  # å½’ä¸€åŒ–ï¼ˆNormalizationï¼‰

# IDFï¼ˆé€†æ–‡æ¡£é¢‘ç‡ / Inverse Document Frequencyï¼‰ï¼šè¶Šç¨€æœ‰çš„è¯æƒé‡è¶Šé«˜
idf = {
    w: math.log((æ€»æ–‡æ¡£æ•° + 1) / (åŒ…å«è¯¥è¯çš„æ–‡æ¡£æ•° + 1)) + 1  # å¹³æ»‘å¤„ç†ï¼ˆSmoothingï¼‰
    for w, df in doc_freq.items()
}

# ä½™å¼¦ç›¸ä¼¼åº¦ï¼ˆCosine Similarityï¼‰ï¼šä¸¤ç¯‡æ–‡ç« æœ‰å¤š"åƒ"
def _cosine_similarity(a, b):
    common = set(a.keys()) & set(b.keys())  # äº¤é›†ï¼ˆIntersectionï¼‰ï¼šå…±æœ‰çš„è¯
    dot = sum(a[k] * b[k] for k in common)  # ç‚¹ç§¯ï¼ˆDot Productï¼‰
    norm_a = sqrt(sum(v*v for v in a.values()))  # L2 èŒƒæ•°ï¼ˆL2 Normï¼‰ï¼šå‘é‡çš„"é•¿åº¦"
    norm_b = sqrt(sum(v*v for v in b.values()))
    return dot / (norm_a * norm_b)           # ç›¸ä¼¼åº¦ âˆˆ [0, 1]
```

#### å…·ä½“æ•°å­—ä¾‹å­

å‡è®¾åªæœ‰ 3 ç¯‡æ–‡æ¡£ï¼š

```
æ–‡æ¡£ Aï¼š"python æœºå™¨å­¦ä¹  æ¢¯åº¦ æ¢¯åº¦ ä¸‹é™"
æ–‡æ¡£ Bï¼š"python web æ¡†æ¶ flask"
æ–‡æ¡£ Cï¼š"æœºå™¨å­¦ä¹  æ·±åº¦å­¦ä¹  ç¥ç»ç½‘ç»œ"
```

æœç´¢ï¼š"python æœºå™¨å­¦ä¹ "

| è¯ | TF(A) | TF(B) | TF(C) | IDF | å«ä¹‰ |
|----|-------|-------|-------|-----|------|
| python | 0.5 | 0.5 | 0 | è¾ƒä½ | å‡ºç°åœ¨ 2/3 æ–‡æ¡£ï¼Œä¸å¤ªç‹¬ç‰¹ï¼ˆä½åŒºåˆ†åº¦ï¼‰ |
| æœºå™¨å­¦ä¹  | 0.5 | 0 | 0.5 | è¾ƒä½ | å‡ºç°åœ¨ 2/3 æ–‡æ¡£ |
| æ¢¯åº¦ | 1.0 | 0 | 0 | **é«˜** | åªå‡ºç°åœ¨ 1/3 æ–‡æ¡£ï¼Œå¾ˆç‹¬ç‰¹ï¼ˆé«˜åŒºåˆ†åº¦ï¼‰ |
| web | 0 | 0.5 | 0 | **é«˜** | åªå‡ºç°åœ¨ 1/3 æ–‡æ¡£ |
| æ·±åº¦å­¦ä¹  | 0 | 0 | 0.5 | **é«˜** | åªå‡ºç°åœ¨ 1/3 æ–‡æ¡£ |

æœç´¢è¯ "python æœºå™¨å­¦ä¹ " åŒæ—¶åŒ…å« python å’Œæœºå™¨å­¦ä¹  â†’ å’Œæ–‡æ¡£ A ä½™å¼¦ç›¸ä¼¼åº¦æœ€é«˜ï¼ˆä¸¤ä¸ªè¯éƒ½åŒ¹é…ï¼‰ï¼Œæ–‡æ¡£ C æ¬¡ä¹‹ï¼ˆåŒ¹é…"æœºå™¨å­¦ä¹ "ï¼‰ï¼Œæ–‡æ¡£ B æœ€ä½ï¼ˆåªåŒ¹é…"python"ï¼‰ã€‚

#### æ•°æ®ç»“æ„

æ¯ç¯‡æ–‡æ¡£è¢«è¡¨ç¤ºæˆä¸€ä¸ª `dict[str, float]`â€”â€”**ç¨€ç–å‘é‡**ï¼ˆ**Sparse Vector**ï¼‰ã€‚

ä¸ºä»€ä¹ˆå«"ç¨€ç–"ï¼ˆ**Sparse**ï¼‰ï¼Ÿå› ä¸ºæ•´ä¸ªè¯è¡¨ï¼ˆ**Vocabulary**ï¼‰å¯èƒ½æœ‰ä¸Šä¸‡ä¸ªè¯ï¼Œä½†ä¸€ç¯‡æ–‡ç« åªç”¨äº†å‡ åä¸ªè¯ã€‚å¦‚æœç”¨æ™®é€šæ•°ç»„ï¼ˆ**Dense Vectorï¼Œç¨ å¯†å‘é‡**ï¼‰å­˜ï¼Œä¸Šä¸‡ä¸ªä½ç½®å¤§éƒ¨åˆ†æ˜¯ 0ï¼Œæµªè´¹å†…å­˜ã€‚ç”¨ dict åªå­˜éé›¶çš„è¯ï¼ˆ**éé›¶ç»´åº¦ / Non-zero Dimensions**ï¼‰ï¼Œç©ºé—´æ•ˆç‡æé«˜ã€‚

---

## å››ã€ç®—æ³•è°ƒç”¨å…³ç³»å…¨æ™¯å›¾

ä¸‹é¢è¿™å¼ å›¾å±•ç¤ºäº†æ‰€æœ‰ç®—æ³•åœ¨å®é™…è¿è¡Œä¸­æ˜¯æ€ä¹ˆè¢«è°ƒç”¨çš„ï¼š

```
ç”¨æˆ·è¾“å…¥ä»»åŠ¡ï¼š"åˆ†æ Python å¹¶å‘æ¨¡å‹"
    â”‚
    â–¼
Planner (LLM è§„åˆ’) â”€â”€â†’ æ„å»º DAGï¼ˆDirected Acyclic Graphï¼‰
    â”‚                      â”‚
    â”‚             _validate_dag()     æ ¡éªŒè¾¹çš„ç«¯ç‚¹ â† dict æŸ¥æ‰¾ï¼ˆHash Lookupï¼‰
    â”‚                      â”‚
    â”‚             topological_sort()  éªŒè¯æ— ç¯ â† Kahn ç®—æ³•ï¼ˆTopological Sortï¼‰+ deque
    â–¼
DAGExecutor.execute() â”€â”€â”€ ä¸»å¾ªç¯ï¼ˆSuper-step / BSP æ¨¡å‹ï¼‰
    â”‚
    â”‚  â”Œâ”€ æ¯ä¸€è½® Super-step â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  get_ready_nodes()           â† åŠ¨æ€è°ƒåº¦ï¼ˆDynamic Schedulingï¼‰         â”‚
    â”‚  â”‚      â””â”€â”€ get_dependency_ids()   â† å…¥è¾¹æŸ¥è¯¢ï¼ˆInbound Edge Queryï¼‰O(E) â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  asyncio.gather()            â† å¹¶å‘æ‰§è¡Œï¼ˆConcurrent Executionï¼‰       â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  StateMachine.transition()   â† çŠ¶æ€è½¬ç§»æ ¡éªŒï¼ˆFSM Validationï¼‰O(1)     â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  merge_result()              â† å…±äº«çŠ¶æ€å†™å…¥ï¼ˆShared State Writeï¼‰     â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  _process_conditions()       â† æ¡ä»¶è¯„ä¼°ï¼ˆCondition Evaluationï¼‰       â”‚
    â”‚  â”‚      â””â”€â”€ mark_subtree_skipped()  â† BFS å¯è¾¾æ€§ + çº§è”è·³è¿‡             â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  _handle_failure()           â† æ•…éšœå¤„ç†ï¼ˆFault Handlingï¼‰             â”‚
    â”‚  â”‚      â””â”€â”€ mark_subtree_skipped()  â† BFSï¼ˆReachability Analysisï¼‰      â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  _complete_structural_nodes() â† è‡ªåº•å‘ä¸Šèšåˆï¼ˆBottom-up Aggregationï¼‰ â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  save_checkpoint()           â† çŠ¶æ€å¿«ç…§ï¼ˆState Snapshotï¼‰             â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”‚
    â”‚  â”Œâ”€ (v3) è‡ªé€‚åº”è§„åˆ’æ£€æŸ¥ç‚¹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  _should_adapt()              â† æ£€æŸ¥æ˜¯å¦æ»¡è¶³è‡ªé€‚åº”è§¦å‘æ¡ä»¶           â”‚
    â”‚  â”‚      â””â”€â”€ get_completed_action_count() â† ç»Ÿè®¡å·²å®Œæˆ ACTION èŠ‚ç‚¹       â”‚
    â”‚  â”‚      â””â”€â”€ get_pending_action_nodes()   â† æŸ¥æ‰¾å¾…æ‰§è¡Œ ACTION èŠ‚ç‚¹       â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  PlannerAgent.adapt_plan()    â† LLM è¯„ä¼°ä¸­é—´ç»“æœï¼Œå†³å®šå¢åˆ æ”¹         â”‚
    â”‚  â”‚  apply_adaptations()          â† åº”ç”¨è°ƒæ•´åˆ° DAGï¼ˆå›¾å˜æ›´æ“ä½œï¼‰         â”‚
    â”‚  â”‚      â””â”€â”€ add_dynamic_node()    â† æ·»åŠ æ–°èŠ‚ç‚¹ï¼ˆID å»é‡ O(1)ï¼‰         â”‚
    â”‚  â”‚      â””â”€â”€ add_dynamic_edge()    â† æ·»åŠ æ–°è¾¹ï¼ˆç«¯ç‚¹æ ¡éªŒ O(1)ï¼‰          â”‚
    â”‚  â”‚      â””â”€â”€ remove_pending_node() â† ç§»é™¤èŠ‚ç‚¹ + å…³è”è¾¹ O(E)             â”‚
    â”‚  â”‚      â””â”€â”€ modify_node()         â† ä¿®æ”¹æè¿°/åˆ¤æ® O(1)                 â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”‚  â”Œâ”€ (v3) ToolRouter å·¥å…·è·¯ç”± â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  â”‚                                                                      â”‚
    â”‚  â”‚  record_success/failure()     â† ç»Ÿè®¡è¿½è¸ªï¼ˆdict åµŒå¥— dict O(1)ï¼‰     â”‚
    â”‚  â”‚  get_hint()                   â† é˜ˆå€¼åˆ¤æ–­ + å»ºè®®ç”Ÿæˆ                  â”‚
    â”‚  â”‚                                                                      â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼ï¼ˆå¦‚æœå¤±è´¥éœ€è¦é‡è§„åˆ’ï¼‰
  _merge_dags()                       â† å›¾çš„é›†åˆè¿ç®—ï¼ˆGraph Set Operationsï¼‰
      â””â”€â”€ get_downstream()               â† BFS ç¡®å®šå¤±è´¥å­æ ‘èŒƒå›´ï¼ˆSubtree Boundaryï¼‰
```

### v3 æ–°å¢çš„ç®—æ³•/æ•°æ®ç»“æ„

| çŸ¥è¯†ç‚¹ | ä½ç½® | è¯´æ˜ |
|--------|------|------|
| **å›¾çš„è¿è¡Œæ—¶å˜æ›´** | `dag/graph.py` 6 ä¸ªæ–°æ–¹æ³• | åœ¨å›¾éå†è¿‡ç¨‹ä¸­åŠ¨æ€ä¿®æ”¹å›¾ç»“æ„ï¼Œéœ€è¦æ³¨æ„åªæ“ä½œ PENDING/READY çŠ¶æ€çš„èŠ‚ç‚¹ï¼ˆé¿å…ç ´åæ‰§è¡Œä¸€è‡´æ€§ï¼‰ |
| **åµŒå¥—å­—å…¸ç»Ÿè®¡** | `tools/router.py` `_stats` | `dict[node_id, dict[tool_name, ToolStats]]` â€” äºŒçº§å“ˆå¸Œè¡¨å®ç°æŒ‰èŠ‚ç‚¹æŒ‰å·¥å…·çš„ O(1) ç»Ÿè®¡æŸ¥è¯¢ |
| **é˜ˆå€¼è§¦å‘ç­–ç•¥** | `tools/router.py` `should_suggest_alternative` | è¿ç»­å¤±è´¥è®¡æ•°å™¨æ¨¡å¼ï¼ˆç±»ä¼¼ç†”æ–­å™¨ / Circuit Breakerï¼‰ï¼ŒæˆåŠŸè°ƒç”¨é‡ç½®è®¡æ•° |

---

## äº”ã€å­¦ä¹ è·¯å¾„å»ºè®®

### æ¨èå­¦ä¹ é¡ºåº

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”Œâ”€â”€â”€â†’â”‚ 4.æ ‘çš„éå† (Tree Traversal)â”‚
               â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1.å›¾çš„è¡¨ç¤º  â”‚â”€â”¼â”€â”€â”€â†’â”‚ 5.æœ‰é™çŠ¶æ€æœº (FSM)         â”‚â”€â”€â”€â†’â”‚ 6.DAG åŠ¨æ€è°ƒåº¦ (Dynamic Scheduling)â”‚
â”‚(Graph Rep.) â”‚ â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â–²
               â”œâ”€â”€â”€â†’â”‚ 2.BFS (å¹¿åº¦ä¼˜å…ˆæœç´¢)       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â””â”€â”€â”€â†’â”‚ 3.æ‹“æ‰‘æ’åº (Topological Sort)â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

       åŸºç¡€(Fundamentals)     ä¸­çº§(Intermediate)        è¿›é˜¶(Advanced)
         å­¦å®Œå°±æ‡‚ 50%           å­¦å®Œå°±æ‡‚ 80%             å­¦å®Œå°±æ‡‚ 100%
```

### è¯¦ç»†å¯¹ç…§è¡¨

| é¡ºåº | çŸ¥è¯†ç‚¹ | è‹±æ–‡ | Demo ä¸­çš„å¯¹åº” | æ¨èç»ƒä¹  |
|------|--------|------|-------------|---------|
| 1 | **å›¾çš„è¡¨ç¤º** | Graph Representation | `TaskDAG.__init__`ï¼ˆdict + listï¼‰ | LeetCode 133 â€” å…‹éš†å›¾ |
| 2 | **BFS** | Breadth-First Search | `get_downstream()`ï¼ˆæ‰¾ä¸‹æ¸¸å­æ ‘ï¼‰ | LeetCode 102 â€” äºŒå‰æ ‘å±‚åºéå† |
| 3 | **æ‹“æ‰‘æ’åº** | Topological Sort (Kahn) | `topological_sort()` | LeetCode 207/210 â€” è¯¾ç¨‹è¡¨ I/II |
| 4 | **æ ‘çš„éå†** | Tree Traversal | `_build_dag_tree()`ï¼ˆå¯è§†åŒ–ï¼‰ | LeetCode 589 â€” N å‰æ ‘å‰åºéå† |
| 5 | **æœ‰é™çŠ¶æ€æœº** | Finite State Machine | `NodeStateMachine`ï¼ˆçŠ¶æ€è½¬ç§»è¡¨ï¼‰ | æ‰‹ç”»è®¢å•çŠ¶æ€è½¬ç§»å›¾ |
| 6 | **DAG åŠ¨æ€è°ƒåº¦** | Dynamic Scheduling | `get_ready_nodes()` + Super-step | è‡ªå·±å®ç°ç®€åŒ–ç‰ˆ `make -j` |

### æ ¸å¿ƒå»ºè®®

- **å…¥é—¨**ï¼šå­¦å®Œ 1-3ï¼ˆå›¾è¡¨ç¤º + BFS + æ‹“æ‰‘æ’åºï¼‰ï¼Œå°±èƒ½ç†è§£ Demo **80%** çš„æ‰§è¡Œé€»è¾‘
- **æœ€ä½³ç»ƒä¹ é¢˜**ï¼šLeetCode 207/210ï¼ˆè¯¾ç¨‹è¡¨ï¼‰è·Ÿ Demo åœºæ™¯**å‡ ä¹ä¸€æ¨¡ä¸€æ ·**â€”â€”è¯¾ç¨‹ä¾èµ– = DEPENDENCY Edgeï¼Œåˆ¤æ–­èƒ½å¦ä¿®å®Œæ‰€æœ‰è¯¾ = DAG Cycle Detection + Topological Sort
- **åŠ¨æ‰‹éªŒè¯**ï¼šè¿è¡Œ Demo çš„å•å…ƒæµ‹è¯•ï¼Œè§‚å¯Ÿç®—æ³•å®é™…è¡Œä¸ºï¼š

```bash
# æ¿€æ´»è™šæ‹Ÿç¯å¢ƒåè¿è¡Œ
python -m pytest tests/ -v

# æ¨èé˜…è¯»é¡ºåºï¼š
# 1. TestHierarchicalPlanning      â†’ æ‹“æ‰‘æ’åº(Topological Sort) + å°±ç»ªå‘ç°(Ready Discovery)
# 2. TestParallelExecutionWithTools â†’ BFS + å¹¶è¡Œ Super-step(BSP)
# 3. TestConditionalBranchAndRollback â†’ æ¡ä»¶åˆ†æ”¯(Conditional Branch) + çº§è”è·³è¿‡(Cascade Skip)
```
